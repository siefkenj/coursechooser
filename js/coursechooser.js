// Generated by CoffeeScript 1.4.0
var BasicCourse, CourseButton, CourseManager, CourseStateButton, CourseUtils, DownloadManager, Electives, ElectivesButton, ElectivesButtonEditor, FileHandler, Graph, PrereqUtils, SVGGraphManager, attachedToDom, dupObject, escapeJSON, htmlEncode, objKeysEqual, objToString, objValsToArray, onPreviewPageShow, parseCourseListString, parseUrlHash, prepareNavMenu, prepareWelcomePage, reparent, showPage, strWidthInEn, symmetricDiffObjects, titleCaps, updatePreview,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

objToString = function(obj) {
  var p, ret, v;
  ret = '{ ';
  for (p in obj) {
    v = obj[p];
    ret += " " + p + ":" + v + ", ";
  }
  return ret + "}";
};

attachedToDom = function(elm) {
  if (!elm || !(elm.parentNode != null)) {
    return false;
  } else if (elm.parentNode === document) {
    return true;
  }
  return attachedToDom(elm.parentNode);
};

objValsToArray = function(obj) {
  var k, v;
  return (function() {
    var _results;
    _results = [];
    for (k in obj) {
      v = obj[k];
      _results.push(v);
    }
    return _results;
  })();
};

symmetricDiffObjects = function(obj1, obj2) {
  var k, ret1, ret2;
  ret1 = {};
  ret2 = {};
  for (k in obj1) {
    if (!obj2[k]) {
      ret1[k] = obj1[k];
    }
  }
  for (k in obj2) {
    if (!obj1[k]) {
      ret2[k] = obj2[k];
    }
  }
  return {
    missing: ret1,
    excess: ret2
  };
};

objKeysEqual = function(obj1, obj2) {
  var k;
  for (k in obj1) {
    if (!(obj2[k] != null)) {
      return false;
    }
  }
  for (k in obj2) {
    if (!(obj1[k] != null)) {
      return false;
    }
  }
  return true;
};

dupObject = function(obj) {
  var k, ret, v;
  ret = {};
  for (k in obj) {
    v = obj[k];
    ret[k] = v;
  }
  return ret;
};

htmlEncode = function(str) {
  str = '' + str;
  try {
    str = str.replace('&', '&amp;', 'g').replace('<', '&lt;', 'g').replace('>', '&gt;', 'g');
  } catch (e) {
    console.log('error, expected string, got', str);
  }
  return str;
};

parseUrlHash = function(hash) {
  var h, m, ret, _i, _len;
  hash = hash.split(/[&?]/);
  ret = {
    hash: null,
    args: []
  };
  for (_i = 0, _len = hash.length; _i < _len; _i++) {
    h = hash[_i];
    if (m = h.match(/^#[\w-]+/)) {
      ret.hash = m[0];
    }
    if (h.match('=')) {
      ret.args.push(h.split('='));
    }
  }
  return ret;
};

escapeJSON = function(str) {
  var c, encodeUnicode, escaped, htmlEscapeToChar, _i, _len, _ref;
  if (typeof str !== 'string') {
    throw new Error('escapeJSON must be called with a string only');
  }
  htmlEscapeToChar = function(str) {
    var code, htmlChars, num;
    if (str.charAt(1) === '#') {
      num = parseInt(str.slice(2, str.length - 1), 10);
      return String.fromCharCode(num);
    }
    htmlChars = {
      nbsp: 32,
      iexcl: 161,
      cent: 162,
      pound: 163,
      curren: 164,
      yen: 165,
      brvbar: 166,
      sect: 167,
      uml: 168,
      copy: 169,
      ordf: 170,
      laquo: 171,
      not: 172,
      shy: 173,
      reg: 174,
      macr: 175,
      deg: 176,
      plusmn: 177,
      sup2: 178,
      sup3: 179,
      acute: 180,
      micro: 181,
      para: 182,
      middot: 183,
      cedil: 184,
      sup1: 185,
      ordm: 186,
      raquo: 187,
      frac14: 188,
      frac12: 189,
      frac34: 190,
      iquest: 191,
      Agrave: 192,
      Aacute: 193,
      Acirc: 194,
      Atilde: 195,
      Auml: 196,
      Aring: 197,
      AElig: 198,
      Ccedil: 199,
      Egrave: 200,
      Eacute: 201,
      Ecirc: 202,
      Euml: 203,
      Igrave: 204,
      Iacute: 205,
      Icirc: 206,
      Iuml: 207,
      ETH: 208,
      Ntilde: 209,
      Ograve: 210,
      Oacute: 211,
      Ocirc: 212,
      Otilde: 213,
      Ouml: 214,
      times: 215,
      Oslash: 216,
      Ugrave: 217,
      Uacute: 218,
      Ucirc: 219,
      Uuml: 220,
      Yacute: 221,
      THORN: 222,
      szlig: 223,
      agrave: 224,
      aacute: 225,
      acirc: 226,
      atilde: 227,
      auml: 228,
      aring: 229,
      aelig: 230,
      ccedil: 231,
      egrave: 232,
      eacute: 233,
      ecirc: 234,
      euml: 235,
      igrave: 236,
      iacute: 237,
      icirc: 238,
      iuml: 239,
      eth: 240,
      ntilde: 241,
      ograve: 242,
      oacute: 243,
      ocirc: 244,
      otilde: 245,
      ouml: 246,
      divide: 247,
      oslash: 248,
      ugrave: 249,
      uacute: 250,
      ucirc: 251,
      uuml: 252,
      yacute: 253,
      thorn: 254,
      yuml: 255,
      fnof: 402,
      Alpha: 913,
      Beta: 914,
      Gamma: 915,
      Delta: 916,
      Epsilon: 917,
      Zeta: 918,
      Eta: 919,
      Theta: 920,
      Iota: 921,
      Kappa: 922,
      Lambda: 923,
      Mu: 924,
      Nu: 925,
      Xi: 926,
      Omicron: 927,
      Pi: 928,
      Rho: 929,
      Sigma: 931,
      Tau: 932,
      Upsilon: 933,
      Phi: 934,
      Chi: 935,
      Psi: 936,
      Omega: 937,
      alpha: 945,
      beta: 946,
      gamma: 947,
      delta: 948,
      epsilon: 949,
      zeta: 950,
      eta: 951,
      theta: 952,
      iota: 953,
      kappa: 954,
      lambda: 955,
      mu: 956,
      nu: 957,
      xi: 958,
      omicron: 959,
      pi: 960,
      rho: 961,
      sigmaf: 962,
      sigma: 963,
      tau: 964,
      upsilon: 965,
      phi: 966,
      chi: 967,
      psi: 968,
      omega: 969,
      thetasym: 977,
      upsih: 978,
      piv: 982,
      bull: 8226,
      hellip: 8230,
      prime: 8242,
      Prime: 8243,
      oline: 8254,
      frasl: 8260,
      weierp: 8472,
      image: 8465,
      real: 8476,
      trade: 8482,
      alefsym: 8501,
      larr: 8592,
      uarr: 8593,
      rarr: 8594,
      darr: 8595,
      harr: 8596,
      crarr: 8629,
      lArr: 8656,
      uArr: 8657,
      rArr: 8658,
      dArr: 8659,
      hArr: 8660,
      forall: 8704,
      part: 8706,
      exist: 8707,
      empty: 8709,
      nabla: 8711,
      isin: 8712,
      notin: 8713,
      ni: 8715,
      prod: 8719,
      sum: 8721,
      minus: 8722,
      lowast: 8727,
      radic: 8730,
      prop: 8733,
      infin: 8734,
      ang: 8736,
      and: 8743,
      or: 8744,
      cap: 8745,
      cup: 8746,
      int: 8747,
      there4: 8756,
      sim: 8764,
      cong: 8773,
      asymp: 8776,
      ne: 8800,
      equiv: 8801,
      le: 8804,
      ge: 8805,
      sub: 8834,
      sup: 8835,
      nsub: 8836,
      sube: 8838,
      supe: 8839,
      oplus: 8853,
      otimes: 8855,
      perp: 8869,
      sdot: 8901,
      lceil: 8968,
      rceil: 8969,
      lfloor: 8970,
      rfloor: 8971,
      lang: 9001,
      rang: 9002,
      loz: 9674,
      spades: 9824,
      clubs: 9827,
      hearts: 9829,
      diams: 9830,
      quot: 34,
      amp: 38,
      lt: 60,
      gt: 62,
      OElig: 338,
      oelig: 339,
      Scaron: 352,
      scaron: 353,
      Yuml: 376,
      circ: 710,
      tilde: 732,
      ensp: 8194,
      emsp: 8195,
      thinsp: 8201,
      zwnj: 8204,
      zwj: 8205,
      lrm: 8206,
      rlm: 8207,
      ndash: 8211,
      mdash: 8212,
      lsquo: 8216,
      rsquo: 8217,
      sbquo: 8218,
      ldquo: 8220,
      rdquo: 8221,
      bdquo: 8222,
      dagger: 8224,
      Dagger: 8225,
      permil: 8240,
      lsaquo: 8249,
      rsaquo: 8250,
      euro: 8364
    };
    code = str.slice(1, str.length - 1);
    num = htmlChars[code];
    if (num === 34) {
      return "\\\"";
    }
    if (num) {
      return String.fromCharCode(num);
    }
    return str;
  };
  encodeUnicode = function(str) {
    var _ref;
    if ((32 <= (_ref = str.charCodeAt(0)) && _ref <= 126)) {
      return str;
    }
    return encodeURIComponent(str);
  };
  escaped = str.replace(/&.*?;/g, htmlEscapeToChar);
  _ref = ['<', '>', '&'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    c = _ref[_i];
    escaped = escaped.replace(c, encodeURIComponent(c), 'g');
  }
  escaped = escaped.replace(/./g, encodeUnicode);
  return escaped;
};

strWidthInEn = function(str) {
  var numSkinny, numSpaces, numWide, _ref, _ref1, _ref2;
  if (str == null) {
    str = '';
  }
  str = '' + str;
  numWide = ((_ref = str.match(/[A-HJ-Zmw]/)) != null ? _ref.length : void 0) || 0;
  numSkinny = ((_ref1 = str.match(/[Iijlt:]/)) != null ? _ref1.length : void 0) || 0;
  numSpaces = ((_ref2 = str.match(/[ ]/)) != null ? _ref2.length : void 0) || 0;
  return str.length + .2 * numWide - .7 * numSkinny - .2 * numSpaces;
};

titleCaps = function(str) {
  var exceptionalWords, firstWord, i, ret, shouldCapitalize, tokens, upper, word, _i, _len, _ref, _ref1;
  if (!str) {
    return '';
  }
  upper = function(word) {
    return word.charAt(0).toUpperCase() + word.slice(1);
  };
  exceptionalWords = /^(a|an|and|as|at|but|by|en|for|if|in|of|on|or|the|to|v[.]?|via|vs[.]?|with|amp|gt|lt)$/;
  str = str.toLowerCase();
  tokens = ('' + str).split(/\b/);
  ret = '';
  firstWord = true;
  for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
    word = tokens[i];
    shouldCapitalize = true;
    if (word.match(exceptionalWords)) {
      shouldCapitalize = false;
    }
    if (firstWord) {
      shouldCapitalize = true;
    }
    if (((_ref = tokens[i - 1]) != null ? _ref.slice(-1) : void 0) === '&' && ((_ref1 = tokens[i + 1]) != null ? _ref1.charAt(0) : void 0) === ';') {
      shouldCapitalize = false;
    }
    if (firstWord && word.match(/\b/)) {
      firstWord = false;
    }
    if (word.match(/^(i|v|x|l|c|d|m)+$/i)) {
      word = word.toUpperCase();
    } else if (shouldCapitalize) {
      word = upper(word);
    }
    ret += word;
  }
  return ret;
};

parseCourseListString = function(val) {
  var courses, i, subject, subjects, unknownCourses, v, _i, _len, _ref;
  subjects = {};
  courses = [];
  unknownCourses = [];
  val = val.toUpperCase();
  val = val.replace(/([A-Z])(\d)/g, "$1 $2");
  val = val.split(/[^a-zA-Z0-9]+/);
  subject = null;
  for (i = _i = 0, _len = val.length; _i < _len; i = ++_i) {
    v = val[i];
    if (v.length === 0) {
      continue;
    }
    if (v.match(/^[a-zA-Z]/)) {
      subject = v;
      if (!((_ref = val[i + 1]) != null ? _ref.match(/^\d/) : void 0)) {
        subjects[subject] = true;
      }
    } else {
      if (!(subject != null)) {
        unknownCourses.push(v);
        continue;
      }
      courses.push({
        subject: subject,
        number: v
      });
    }
  }
  return {
    courses: courses,
    subjects: subjects,
    unknownCourses: unknownCourses
  };
};

reparent = function(elm, newParent, ops) {
  var newOffset, oldOffset, tmp;
  if (ops == null) {
    ops = {};
  }
  if (!ops.animate) {
    $(elm).appendTo(newParent);
    return;
  }
  elm = $(elm);
  newParent = $(newParent);
  oldOffset = ops.origin || elm.offset();
  elm.appendTo(newParent);
  newOffset = ops.target || elm.offset();
  tmp = elm.clone().appendTo('body');
  tmp.css({
    position: 'absolute',
    left: oldOffset.left,
    top: oldOffset.top,
    'zIndex': 1000
  });
  elm.css({
    visibility: 'hidden'
  });
  tmp.animate({
    top: newOffset.top,
    left: newOffset.left
  }, {
    duration: 750,
    easing: 'easeOutCubic',
    complete: function() {
      elm.show();
      elm.css({
        visibility: 'visible'
      });
      tmp.remove();
      if (ops.complete && !ops.complete.hasRun) {
        ops.complete();
        return ops.complete.hasRun = true;
      }
    }
  });
};

$(document).ready(function() {
  var ZOOM_FACTOR, arg, locHash, preloadSubjects, subject, _i, _j, _len, _len1, _ref, _ref1;
  $('.course-status').buttonset().disableSelection();
  $('button').button();
  $('#department-list').combobox().combobox('value', '');
  $('#tabs,.tabs').tabs();
  /*
      $(document).tooltip
          show:
              effect: 'fade'
              delay: 1000
  */

  locHash = parseUrlHash(window.location.hash);
  window.location.hash = window.location.hash || '#welcome';
  prepareWelcomePage();
  prepareNavMenu();
  window.courseManager = new CourseManager;
  window.courses = window.courseManager.courses;
  preloadSubjects = [];
  _ref = locHash.args;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    arg = _ref[_i];
    if (arg[0] === 'load') {
      preloadSubjects = preloadSubjects.concat(((_ref1 = arg[1]) != null ? _ref1.split(/,/) : void 0) || []);
    }
  }
  for (_j = 0, _len1 = preloadSubjects.length; _j < _len1; _j++) {
    subject = preloadSubjects[_j];
    window.courseManager.showCoursesOfSubject(subject);
  }
  $('#show-courses').click(function() {
    var c, courses, createDisplayCallback, createErrorCallback, errorMsgHash, subjects, unknownCourses, v, _k, _l, _len2, _len3, _ref2, _results;
    errorMsgHash = {};
    subjects = {};
    courses = [];
    unknownCourses = [];
    try {
      _ref2 = parseCourseListString($('#department-list').combobox('value')), courses = _ref2.courses, subjects = _ref2.subjects, unknownCourses = _ref2.unknownCourses;
    } catch (e) {
      subjects[$('#department-list option:selected()').val()] = true;
    }
    for (v in subjects) {
      createErrorCallback = function(sub) {
        return function() {
          errorMsgHash["Could not load subject '" + sub + "'"] = true;
          return $('#department-list').combobox('showError', ((function() {
            var _results;
            _results = [];
            for (e in errorMsgHash) {
              _results.push(e);
            }
            return _results;
          })()).join('<br/>'));
        };
      };
      try {
        window.courseManager.showCoursesOfSubject(v, {
          error: createErrorCallback(v),
          animate: 'slow'
        });
      } catch (e) {
        console.log(e);
      }
    }
    for (_k = 0, _len2 = courses.length; _k < _len2; _k++) {
      c = courses[_k];
      createErrorCallback = function(sub) {
        return function() {
          errorMsgHash["Could not load course '" + sub.subject + " " + sub.number + "'"] = true;
          return $('#department-list').combobox('showError', ((function() {
            var _results;
            _results = [];
            for (e in errorMsgHash) {
              _results.push(e);
            }
            return _results;
          })()).join('<br/>'));
        };
      };
      createDisplayCallback = function(c) {
        return function() {
          return window.courseManager.ensureDisplayedInYearChart(c, {
            error: createErrorCallback(c),
            animate: 'slow'
          });
        };
      };
      try {
        window.courseManager.loadSubjectData(c.subject, createDisplayCallback(c), {
          error: createErrorCallback(c),
          animate: 'slow'
        });
      } catch (e) {
        console.log(e);
      }
    }
    _results = [];
    for (_l = 0, _len3 = unknownCourses.length; _l < _len3; _l++) {
      c = unknownCourses[_l];
      errorMsgHash["Could not determine subject code for course '" + c + "'"] = true;
      _results.push($('#department-list').combobox('showError', ((function() {
        var _results1;
        _results1 = [];
        for (e in errorMsgHash) {
          _results1.push(e);
        }
        return _results1;
      })()).join('<br/>')));
    }
    return _results;
  });
  $('#show-courses .throbber').ajaxStart(function() {
    return $(this).show();
  }).ajaxComplete(function() {
    return $(this).hide();
  });
  $('#hide-courses').click(function() {
    var c, courses, subjects, unknownCourses, v, _k, _len2, _ref2, _results;
    subjects = {};
    courses = [];
    unknownCourses = [];
    try {
      _ref2 = parseCourseListString($('#department-list').combobox('value')), courses = _ref2.courses, subjects = _ref2.subjects, unknownCourses = _ref2.unknownCourses;
    } catch (e) {
      subjects[$('#department-list option:selected()').val()] = true;
    }
    for (v in subjects) {
      window.courseManager.hideCoursesOfSubject(v, {
        animate: 'slow'
      });
    }
    _results = [];
    for (_k = 0, _len2 = courses.length; _k < _len2; _k++) {
      c = courses[_k];
      _results.push(window.courseManager.hideCourse(c, {
        animate: 'slow'
      }));
    }
    return _results;
  });
  $('.year').droppable({
    hoverClass: 'highlight',
    tolerance: 'pointer',
    drop: function(event, ui) {
      var courses;
      courses = this.getElementsByClassName('courses')[0];
      courses.appendChild(ui.draggable[0]);
      window.courseManager.selectCourse(ui.draggable[0].course);
      return window.courseManager.courseMoved(ui.draggable[0].course);
    }
  });
  $('#create-new-electives').click(function() {
    var elective, electiveButton;
    elective = new ElectivesButtonEditor({
      title: 'Electives'
    }, window.courseManager);
    electiveButton = new ElectivesButton(elective);
    $('#electives-list').append(elective.getButton());
    $('.year1 .courses').append(electiveButton.getButton());
    window.courseManager.addCourse(electiveButton);
    window.courseManager.sortableCourses[electiveButton] = electiveButton;
    window.courseManager.addCourse(elective);
    window.courseManager.makeCourseButtonDraggable(electiveButton);
    window.courseManager.makeElectivesButtonDroppable(electiveButton);
    window.courseManager.makeElectivesButtonClickable(electiveButton);
    return window.courseManager.makeElectivesButtonClickable(elective);
  });
  $('#save').click(function() {
    var baseName, clonedSvg, data, downloadManager, elm, mimeType, name, _k, _l, _len2, _len3, _ref2, _ref3;
    window.courseManager.updateGraphState();
    baseName = (window.courseManager.graphState.title || "course-map").replace(/\W/g, '_');
    name = baseName + ".json";
    data = window.courseManager.graphState.toJSON();
    mimeType = 'application/json';
    if ($('a[page=#preview]').hasClass('active')) {
      name = baseName + '.svg';
      clonedSvg = window.courseManager.svgManager.svgGraph.svg.cloneNode(true);
      _ref2 = $(clonedSvg).find('.highlight');
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        elm = _ref2[_k];
        SVGGraphManager.utils.removeClass(elm, 'highlight');
      }
      _ref3 = $(clonedSvg).find('.selected');
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        elm = _ref3[_l];
        SVGGraphManager.utils.removeClass(elm, 'selected');
      }
      window.courseManager.svgManager.svgGraph.inlineDocumentStyles(clonedSvg);
      window.courseManager.svgManager.svgGraph.addCDATA({
        svg: clonedSvg,
        elmName: 'coursemapper',
        data: escapeJSON(window.courseManager.graphState.toJSON())
      });
      clonedSvg.setAttribute('width', '8.5in');
      clonedSvg.setAttribute('height', '11in');
      clonedSvg.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      if (parseFloat(clonedSvg.getAttribute('aspect')) > 8.5 / 11) {
        clonedSvg.setAttribute('width', '8.5in');
      }
      data = $('<div></div>').append(clonedSvg).html();
      mimeType = 'image/svg+xml';
    }
    downloadManager = new DownloadManager(name, data, mimeType);
    return downloadManager.download();
  });
  $('#load').click(function() {
    var dialog;
    dialog = $('<div>\n<h3>Browse for the file you wish to upload</h3>\n<input type="file" id="files" name="files[]" accept="application/json" />\n</div>');
    $(document.body).append(dialog);
    dialog.dialog({
      height: 300,
      width: 500,
      modal: true
    });
    return dialog.find('input').change(function(event) {
      var files;
      files = event.target.files;
      FileHandler.handleFiles(files);
      return dialog.remove();
    });
  });
  ZOOM_FACTOR = 1.25;
  $('#zoom-preview-in').click(function() {
    var height, svg, width;
    svg = $('#map-container svg')[0];
    width = parseFloat(svg.getAttribute('width'));
    height = parseFloat(svg.getAttribute('height'));
    svg.setAttribute('width', width * ZOOM_FACTOR);
    return svg.setAttribute('height', height * ZOOM_FACTOR);
  });
  $('#zoom-preview-out').click(function() {
    var height, svg, width;
    svg = $('#map-container svg')[0];
    width = parseFloat(svg.getAttribute('width'));
    height = parseFloat(svg.getAttribute('height'));
    svg.setAttribute('width', width / ZOOM_FACTOR);
    return svg.setAttribute('height', height / ZOOM_FACTOR);
  });
  $('#toggleEdge').click(function() {
    var edge, elm1, elm2, svgManager, _ref2,
      _this = this;
    svgManager = window.courseManager.svgManager;
    if (!(svgManager && svgManager.selected[0] && svgManager.selected[1])) {

    } else {
      elm1 = svgManager.selected[0].getAttribute('id').replace('-', ' ');
      elm2 = svgManager.selected[1].getAttribute('id').replace('-', ' ');
      edge = window.courseManager.graphState.edges[[elm1, elm2]];
      edge = edge || window.courseManager.graphState.edges[[elm2, elm1]];
      if (edge) {
        if ((_ref2 = edge.properties.style) != null ? _ref2.match(/invis/) : void 0) {
          edge.properties.style = '';
        } else {
          edge.properties.style = 'invis';
          if (!edge.properties.autoGenerated) {
            window.courseManager.graphState.removeEdge(edge.edge);
          }
        }
      } else {
        window.courseManager.graphState.addEdge([elm1, elm2]);
      }
      updatePreview({
        preserveSelection: true,
        start: function() {
          return $(_this).find('span').append('<img class="throbber" src="image/ajax-loader.gif"/>');
        },
        finish: function() {
          return $(_this).find('.throbber').remove();
        }
      });
    }
  });
  $('#toggleCoreq').click(function() {
    var edge, elm1, elm2, svgManager,
      _this = this;
    svgManager = window.courseManager.svgManager;
    if (!(svgManager && svgManager.selected[0] && svgManager.selected[1])) {

    } else {
      elm1 = svgManager.selected[0].getAttribute('id').replace('-', ' ');
      elm2 = svgManager.selected[1].getAttribute('id').replace('-', ' ');
      edge = window.courseManager.graphState.edges[[elm1, elm2]];
      edge = edge || window.courseManager.graphState.edges[[elm2, elm1]];
      if (!edge) {
        return;
      }
      edge.properties.coreq = !edge.properties.coreq;
      updatePreview({
        preserveSelection: true,
        start: function() {
          return $(_this).find('span').append('<img class="throbber" src="image/ajax-loader.gif"/>');
        },
        finish: function() {
          return $(_this).find('.throbber').remove();
        }
      });
    }
  });
  $('#reverseEdge').click(function() {
    var edge, elm1, elm2, svgManager, _ref2,
      _this = this;
    svgManager = window.courseManager.svgManager;
    if (!(svgManager && svgManager.selected[0] && svgManager.selected[1])) {

    } else {
      elm1 = svgManager.selected[0].getAttribute('id').replace('-', ' ');
      elm2 = svgManager.selected[1].getAttribute('id').replace('-', ' ');
      edge = window.courseManager.graphState.edges[[elm1, elm2]];
      edge = edge || window.courseManager.graphState.edges[[elm2, elm1]];
      if (edge) {
        if ((_ref2 = edge.properties.style) != null ? _ref2.match(/invis/) : void 0) {
          edge.properties.style = '';
        } else {
          edge.properties.style = 'invis';
          if (!edge.properties.autoGenerated) {
            window.courseManager.graphState.removeEdge(edge.edge);
          }
        }
        window.courseManager.graphState.addEdge([elm2, elm1]);
      }
      updatePreview({
        preserveSelection: true,
        start: function() {
          return $(_this).find('span').append('<img class="throbber" src="image/ajax-loader.gif"/>');
        },
        finish: function() {
          return $(_this).find('.throbber').remove();
        }
      });
    }
  });
  return typeof window.onhashchange === "function" ? window.onhashchange() : void 0;
});

prepareWelcomePage = function() {
  var $elm, $link, elm, makeLinkShow, _i, _len, _ref;
  makeLinkShow = function(link, elm) {
    var hide, show;
    show = function() {
      elm.show();
      return link.html("Hide Details");
    };
    hide = function() {
      elm.hide();
      return link.html("Show Details");
    };
    return link.toggle(show, hide);
  };
  _ref = $("#welcome li div.more");
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    elm = _ref[_i];
    $elm = $(elm);
    $elm.hide();
    $link = $('<a class="more" href="javascript: void 0;">Show Details</a>').appendTo($elm.parent().find('p')[0]);
    makeLinkShow($link, $elm);
  }
  $('#goto-course-chooser').click(function() {
    return showPage('#course-chooser', {
      animate: true,
      complete: (function() {
        return $('#show-courses').trigger('click');
      })
    });
  });
};

prepareNavMenu = function() {
  var elm, makeLinkShow, target, _i, _len, _ref;
  makeLinkShow = function(link, target) {
    return link.click(function() {
      return showPage(target, {
        animate: false
      });
    });
  };
  _ref = $('#menu-nav a');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    elm = _ref[_i];
    elm = $(elm);
    target = elm.attr('href');
    makeLinkShow(elm, target);
  }
  $('a[page=#preview]').click(function() {
    return onPreviewPageShow();
  });
  window.onhashchange = function() {
    var hash;
    hash = parseUrlHash(window.location.hash).hash;
    return $("a[page=" + hash + "]").click();
  };
};

showPage = function(page, ops) {
  var container, currentPageContainers, doesntNeedAnimation, elm, id, needsAnimation, newPageContainers, offsets, target, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1;
  if (ops == null) {
    ops = {};
  }
  if (typeof page !== 'string') {
    throw new Error("showPage expects page to be a string, not " + page);
  }
  _ref = $('#menu-nav a');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    elm = _ref[_i];
    elm = $(elm);
    if (elm.attr('page') === page) {
      elm.addClass('active');
    } else {
      elm.removeClass('active');
    }
  }
  target = $(page);
  if (!ops.animate) {
    $('.page').hide();
    _ref1 = target.find('.container');
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      elm = _ref1[_j];
      id = elm.getAttribute('contains');
      reparent($(id), elm, ops);
    }
    target.show();
    return;
  }
  currentPageContainers = (function() {
    var _k, _len2, _ref2, _results;
    _ref2 = $($('.page:visible')).find('.container');
    _results = [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      elm = _ref2[_k];
      _results.push(elm.getAttribute('contains'));
    }
    return _results;
  })();
  newPageContainers = (function() {
    var _k, _len2, _ref2, _results;
    _ref2 = target.find('.container');
    _results = [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      elm = _ref2[_k];
      _results.push(elm.getAttribute('contains'));
    }
    return _results;
  })();
  needsAnimation = [];
  doesntNeedAnimation = [];
  for (_k = 0, _len2 = newPageContainers.length; _k < _len2; _k++) {
    elm = newPageContainers[_k];
    if (currentPageContainers.indexOf(elm) >= 0) {
      needsAnimation.push(elm);
    } else {
      doesntNeedAnimation.push(elm);
    }
  }
  offsets = {};
  for (_l = 0, _len3 = needsAnimation.length; _l < _len3; _l++) {
    elm = needsAnimation[_l];
    offsets[elm] = $(elm).offset();
  }
  for (_m = 0, _len4 = doesntNeedAnimation.length; _m < _len4; _m++) {
    elm = doesntNeedAnimation[_m];
    container = target.find(".container[contains=" + elm + "]");
    reparent(elm, container, ops);
  }
  $('.page').hide();
  target.show();
  for (_n = 0, _len5 = needsAnimation.length; _n < _len5; _n++) {
    elm = needsAnimation[_n];
    container = target.find(".container[contains=" + elm + "]");
    reparent(elm, container, {
      animate: true,
      origin: offsets[elm],
      complete: ops.complete
    });
  }
};

updatePreview = function(ops) {
  var render;
  if (ops == null) {
    ops = {
      preserveSelection: false
    };
  }
  if (typeof ops.start === "function") {
    ops.start();
  }
  render = function() {
    var dotCode;
    $('#preview-status .message-text').text("Updating Graph");
    $('#preview-status').show();
    dotCode = window.courseManager.createDotGraph();
    window.Viz.onmessage = function(event) {
      var aspect, ast, data, elm, height, i, id, oldSelection, oldSvgManager, preview, svgManager, width, xdotCode, _i, _j, _len, _len1, _ref;
      data = event.data;
      if (data.type !== 'graph') {
        throw new Error('Need the webworker to return graph type!');
      }
      xdotCode = data.message;
      xdotCode = xdotCode.slice(xdotCode.indexOf('digraph {'));
      ast = DotParser.parse(xdotCode);
      svgManager = new SVGGraphManager(new SVGDot(ast));
      oldSvgManager = window.courseManager.svgManager;
      oldSelection = [];
      if (oldSvgManager && ops.preserveSelection) {
        _ref = oldSvgManager.selected || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elm = _ref[_i];
          if (elm) {
            oldSelection.push(elm.getAttribute('id'));
          }
        }
      }
      window.courseManager.initializeSVGManager(svgManager);
      for (i = _j = 0, _len1 = oldSelection.length; _j < _len1; i = ++_j) {
        id = oldSelection[i];
        svgManager.select($(svgManager.svg).find("#" + id)[0]);
      }
      preview = svgManager.svg;
      aspect = parseFloat(preview.getAttribute('aspect'));
      if (aspect) {
        width = $('#map-container').width();
        height = $('#map-container').height();
        preview.setAttribute('width', Math.round(width));
        preview.setAttribute('height', Math.round(width / aspect));
      }
      $('#map-container').html(preview);
      if (typeof ops.finish === "function") {
        ops.finish();
      }
      return $('#preview-status').fadeOut('fast');
    };
    return window.Viz.postMessage(dotCode);
  };
  return window.setTimeout(render, 0);
};

onPreviewPageShow = function() {
  if (!(window.Viz != null)) {
    window.Viz = new Worker('js/viz-worker.js');
    return window.Viz.onmessage = function(event) {
      var data;
      data = event.data;
      if (data.type === 'status' && data.message === 'viz-loaded') {
        $('#preview-status').hide();
        $('#map-holder').show();
        return updatePreview();
      }
    };
    /*
            #$('#preview-status').html 'loading graphviz library'
            $.getScript 'js/viz-2.26.3.js', ->
                $('#preview-status').hide()
                $('#map-holder').show()
                updatePreview()
    */

  } else {
    return window.setTimeout(updatePreview, 0);
  }
};

SVGGraphManager = (function() {
  var addClass, removeClass;

  addClass = function(elm, cls) {
    var oldCls;
    oldCls = elm.getAttribute('class');
    if (oldCls.split(/\s+/).indexOf(cls) >= 0) {
      return;
    }
    return elm.setAttribute('class', oldCls + ' ' + cls);
  };

  removeClass = function(elm, cls) {
    var c, newCls, oldCls;
    oldCls = elm.getAttribute('class');
    newCls = (function() {
      var _i, _len, _ref, _results;
      _ref = oldCls.split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (c !== cls) {
          _results.push(c);
        }
      }
      return _results;
    })();
    return elm.setAttribute('class', newCls.join(' '));
  };

  SVGGraphManager.utils = {
    addClass: addClass,
    removeClass: removeClass
  };

  function SVGGraphManager(svgGraph) {
    var _this = this;
    this.svgGraph = svgGraph;
    this.svgGraph.render();
    this.svg = this.svgGraph.svg;
    this.$svg = $(this.svgGraph.svg);
    this.$svg.find('.node').click(function(event) {
      var id, number, subject, _ref;
      id = event.currentTarget.getAttribute('id');
      _ref = id.split('-'), subject = _ref[0], number = _ref[1];
      return _this.nodeClicked({
        subject: subject,
        number: number
      });
    });
    this.selected = [null, null];
  }

  SVGGraphManager.prototype.selectEdgeBetween = function(elm1, elm2) {
    var edge, id1, id2, _i, _j, _len, _len1, _ref, _ref1, _results;
    id1 = elm1.getAttribute('id');
    id2 = elm2.getAttribute('id');
    _ref = this.$svg.find("[target=" + id1 + "][origin=" + id2 + "]");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      addClass(edge, 'highlight');
    }
    _ref1 = this.$svg.find("[target=" + id2 + "][origin=" + id1 + "]");
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      edge = _ref1[_j];
      _results.push(addClass(edge, 'highlight'));
    }
    return _results;
  };

  SVGGraphManager.prototype.select = function(elm) {
    if (this.selected[0] && this.selected[1]) {
      this.deselct(this.selected[0]);
      this.selected[0] = this.selected[1];
      this.selected[1] = elm;
    } else if (this.selected[0]) {
      this.selected[1] = elm;
    } else {
      this.selected[0] = elm;
    }
    addClass(elm, 'selected');
    if (this.selected[0] && this.selected[1]) {
      this.selectEdgeBetween(this.selected[0], this.selected[1]);
    }
    return typeof this.selectionChanged === "function" ? this.selectionChanged() : void 0;
  };

  SVGGraphManager.prototype.deselct = function(elm) {
    var i;
    i = this.selected.indexOf(elm);
    if (i >= 0) {
      this.selected[i] = null;
    }
    removeClass(elm, 'selected');
    return typeof this.selectionChanged === "function" ? this.selectionChanged() : void 0;
  };

  SVGGraphManager.prototype.deselectAll = function() {
    var elm, _i, _j, _len, _len1, _ref, _ref1;
    _ref = this.$svg.find('.selected');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      removeClass(elm, 'selected');
    }
    _ref1 = this.$svg.find('.highlight');
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      elm = _ref1[_j];
      removeClass(elm, 'highlight');
    }
    this.selected[0] = null;
    this.selected[1] = null;
    return typeof this.selectionChanged === "function" ? this.selectionChanged() : void 0;
  };

  SVGGraphManager.prototype.nodeClicked = function(course) {
    var clickedNode, edge, _i, _len, _ref;
    clickedNode = $("#" + course.subject + "-" + course.number)[0];
    _ref = this.$svg.find('.edge.highlight');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      edge = _ref[_i];
      removeClass(edge, 'highlight');
    }
    if (this.selected.indexOf(clickedNode) >= 0) {
      this.deselct(clickedNode);
      return;
    }
    if (this.selected[1] && !this.selected[0]) {
      this.selected[0] = this.selected[1];
      this.selected[1] = null;
    }
    return this.select(clickedNode);
  };

  SVGGraphManager.prototype.highlightPrereqPath = function(course) {
    var elm, highlight, _i, _len, _ref,
      _this = this;
    _ref = this.$svg.find('.highlight');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      removeClass(elm, 'highlight');
    }
    highlight = function(node) {
      var arrow, id, _j, _len1, _ref1, _results;
      console.log('highlighting', node);
      addClass($(node)[0], "highlight");
      id = $(node).attr('id');
      _ref1 = _this.$svg.find("[target=" + id + "]");
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        arrow = _ref1[_j];
        addClass(arrow, "highlight");
        _results.push(highlight($("#" + (arrow.attr('origin')))));
      }
      return _results;
    };
    highlight("#" + course.subject + "-" + course.number);
    return console.log(course, course.subject, course.number);
  };

  return SVGGraphManager;

})();

/*
# Class to manage and keep the sync of all course on the webpage
# and their state.
*/


CourseManager = (function() {

  CourseManager.prototype.DISPLAYABLE_STATES = ['required', 'elective', 'core'];

  function CourseManager() {
    this.courseDataLoaded = __bind(this.courseDataLoaded, this);
    this.courses = {};
    this.courseData = {};
    this.sortableCourses = {};
    this.sortableCoursesStateButtons = {};
    this.loadedSubjects = {};
    this.loadingStatus = {};
    this.onSubjectLoadedCallbacks = {};
    this.graphState = new Graph;
  }

  CourseManager.prototype.updateGraphState = function() {
    var cluster, clusterHash, clusters, course, courses, elm, filterDisplayable, getAveEnrollment, hash, year, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1, _ref2,
      _this = this;
    getAveEnrollment = function(course) {
      var arr, c, crn, crns, num, sumC, sumE, term, val, _i, _len, _ref, _ref1;
      crns = {};
      _ref1 = ((_ref = course.data) != null ? _ref.terms_offered : void 0) || {};
      for (term in _ref1) {
        arr = _ref1[term];
        for (_i = 0, _len = arr.length; _i < _len; _i++) {
          c = arr[_i];
          crns[c.crn] = [c.enrollment, c.capacity];
        }
      }
      sumE = 0;
      sumC = 0;
      num = 0;
      for (crn in crns) {
        val = crns[crn];
        sumE += val[0];
        sumC += val[1];
        num += 1;
      }
      return [Math.round(sumE), Math.round(sumC), num];
    };
    this.graphState.title = $('#program-info input').val();
    filterDisplayable = function(list) {
      var c, state, _i, _len, _ref, _ref1;
      if (!list) {
        return list;
      }
      if (!(list.length != null)) {
        _ref = _this.DISPLAYABLE_STATES;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          state = _ref[_i];
          if ((_ref1 = list.state) != null ? _ref1[state] : void 0) {
            return true;
          }
        }
        return false;
      }
      return (function() {
        var _j, _len1, _results;
        _results = [];
        for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
          c = list[_j];
          if (filterDisplayable(c)) {
            _results.push(c);
          }
        }
        return _results;
      })();
    };
    courses = {};
    for (year = _i = 1; _i <= 4; year = ++_i) {
      _ref = $(".year" + year + " .course");
      for (_j = 0, _len = _ref.length; _j < _len; _j++) {
        elm = _ref[_j];
        hash = BasicCourse.hashCourse({
          subject: elm.getAttribute('subject'),
          number: elm.getAttribute('number')
        });
        course = this.sortableCourses[hash];
        if (filterDisplayable(course)) {
          courses[hash] = {
            course: course,
            year: year
          };
        }
      }
    }
    clusters = {};
    for (year = _k = 1; _k <= 4; year = ++_k) {
      _ref1 = $(".year" + year + " .electives-block");
      for (_l = 0, _len1 = _ref1.length; _l < _len1; _l++) {
        cluster = _ref1[_l];
        clusterHash = BasicCourse.hashCourse({
          subject: cluster.getAttribute('subject'),
          number: cluster.getAttribute('number')
        });
        clusters[clusterHash] = {
          cluster: this.sortableCourses[clusterHash],
          year: year,
          courses: []
        };
        _ref2 = $(cluster).find('.course');
        for (_m = 0, _len2 = _ref2.length; _m < _len2; _m++) {
          elm = _ref2[_m];
          hash = BasicCourse.hashCourse({
            subject: elm.getAttribute('subject'),
            number: elm.getAttribute('number')
          });
          course = this.sortableCourses[hash];
          if (filterDisplayable(course)) {
            clusters[clusterHash].courses.push(course);
          }
        }
      }
    }
    this.graphState.nodes = courses;
    this.graphState.clusters = clusters;
    this.graphState.pruneOrphanedEdges();
    this.graphState.generateEdges();
    return this.graphState;
  };

  CourseManager.prototype.clearAll = function() {
    var course, courses, hash, _i, _len, _ref;
    _ref = this.courses;
    for (hash in _ref) {
      courses = _ref[hash];
      for (_i = 0, _len = courses.length; _i < _len; _i++) {
        course = courses[_i];
        if (typeof course.removeButton === "function") {
          course.removeButton();
        }
      }
      this.courses[hash] = null;
    }
    this.courses = {};
    this.courseData = {};
    this.sortableCourses = {};
    this.sortableCoursesStateButtons = {};
    this.loadedSubjects = {};
    this.loadingStatus = {};
    this.onSubjectLoadedCallbacks = {};
    return this.graphState.clearAll();
  };

  CourseManager.prototype.loadGraph = function(str) {
    var cluster, course, courseLoadCallback, createCourseLoadCallback, elective, electiveButton, hash, node, _, _i, _len, _ref, _ref1, _ref2,
      _this = this;
    this.clearAll();
    this.graphState.fromJSON(str);
    $('#program-info input').val(this.graphState.title);
    courseLoadCallback = {};
    createCourseLoadCallback = function(electivesBlock) {
      var ret;
      ret = function(course) {
        electivesBlock.addCourse(course);
        return _this.updateElectivesButton(electivesBlock);
      };
      return ret;
    };
    _ref = this.graphState.clusters;
    for (_ in _ref) {
      cluster = _ref[_];
      elective = new ElectivesButtonEditor(cluster.cluster, this);
      electiveButton = new ElectivesButton(elective);
      $('#electives-list').append(elective.getButton());
      $(".year" + cluster.year + " .courses").append(electiveButton.getButton());
      this.addCourse(electiveButton);
      this.sortableCourses[electiveButton] = electiveButton;
      this.addCourse(elective);
      this.makeCourseButtonDraggable(electiveButton);
      this.makeElectivesButtonDroppable(electiveButton);
      this.makeElectivesButtonClickable(electiveButton);
      this.makeElectivesButtonClickable(elective);
      _ref1 = cluster.courses;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        course = _ref1[_i];
        hash = BasicCourse.hashCourse(course);
        courseLoadCallback[hash] = createCourseLoadCallback(electiveButton);
      }
    }
    _ref2 = this.graphState.nodes;
    for (_ in _ref2) {
      node = _ref2[_];
      course = node.course;
      hash = BasicCourse.hashCourse(course);
      this.ensureDisplayedInYearChart(course, {
        state: course.state,
        year: node.year,
        load: courseLoadCallback[hash]
      });
    }
    if ($('a[page=#preview]').hasClass('active')) {
      window.setTimeout(updatePreview, 1000);
    }
    return this.graphState;
  };

  CourseManager.prototype.initializeSVGManager = function(svgManager) {
    var idToCourse;
    idToCourse = function(id) {
      var number, subject, _ref;
      _ref = id.split('-'), subject = _ref[0], number = _ref[1];
      return {
        subject: subject,
        number: number
      };
    };
    this.svgManager = svgManager;
    this.svgManager.selectionChanged = function() {
      var course1, course2, edge, elm, reverseEdge, tmp, toggleCoreq, toggleEdge, _ref;
      if (!(svgManager.selected[0] && svgManager.selected[1])) {
        elm = 0;
        if (svgManager.selected[0]) {
          elm = svgManager.selected[0].getAttribute('id');
        }
        if (svgManager.selected[1]) {
          elm = svgManager.selected[1].getAttribute('id');
        }
        if (elm) {
          course1 = window.courseManager.createCourseButton(idToCourse(elm));
        }
      } else {
        course1 = idToCourse(svgManager.selected[0].getAttribute('id'));
        course2 = idToCourse(svgManager.selected[1].getAttribute('id'));
        course1 = window.courseManager.createCourseButton(course1);
        course2 = window.courseManager.createCourseButton(course2);
        edge = window.courseManager.graphState.edges[[course1, course2]];
        if (!edge && window.courseManager.graphState.edges[[course2, course1]]) {
          edge = window.courseManager.graphState.edges[[course2, course1]];
          tmp = course1;
          course1 = course2;
          course2 = tmp;
        }
      }
      if (course1) {
        $('#course1 .course-container').html(course1.$elm);
        $('#course1 .course-standin').hide();
      } else {
        $('#course1 .course-container').html('');
        $('#course1 .course-standin').show();
      }
      if (course2) {
        $('#course2 .course-container').html(course2.$elm);
        $('#course2 .course-standin').hide();
      } else {
        $('#course2 .course-container').html('');
        $('#course2 .course-standin').show();
      }
      toggleEdge = $('#toggleEdge');
      toggleCoreq = $('#toggleCoreq');
      reverseEdge = $('#reverseEdge');
      if (course1 && course2) {
        toggleEdge.button('enable');
      } else {
        toggleEdge.button('disable');
      }
      if (!edge || ((_ref = edge.properties.style) != null ? _ref.match(/invis/) : void 0)) {
        $('#edge1').attr({
          "class": 'noArrow'
        });
        toggleEdge.find('span').text(toggleEdge.attr('op1'));
        toggleCoreq.button('disable');
        reverseEdge.button('disable');
      } else {
        toggleCoreq.button('enable');
        toggleEdge.find('span').text(toggleEdge.attr('op2'));
        if (edge.properties.coreq) {
          $('#edge1').attr({
            "class": 'coreqArrow'
          });
          toggleCoreq.find('span').text(toggleCoreq.attr('op2'));
          reverseEdge.button('disable');
        } else {
          $('#edge1').attr({
            "class": 'prereqArrow'
          });
          toggleCoreq.find('span').text(toggleCoreq.attr('op1'));
          reverseEdge.button('enable');
        }
      }
    };
    return this.svgManager.selectionChanged();
  };

  CourseManager.prototype.updateCourseState = function(course, state, ops) {
    var c, hash, _i, _len, _ref,
      _this = this;
    if (ops == null) {
      ops = {
        updatePrereqs: true
      };
    }
    hash = BasicCourse.hashCourse(course);
    _ref = this.courses[hash] || [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if (!c.selectable) {
        state = dupObject(state);
        delete state.selected;
      }
      c.setState(state);
    }
    if (ops.updatePrereqs) {
      return window.setTimeout((function() {
        return _this.showUnmetPrereqs();
      }), 500);
    }
  };

  CourseManager.prototype.addCourse = function(course) {
    var hash;
    hash = '' + course;
    if (!this.courses[hash]) {
      this.courses[hash] = [];
    }
    this.courses[hash].push(course);
    return course;
  };

  CourseManager.prototype.removeCourse = function(course) {
    var hash, index;
    hash = '' + course;
    if (!this.courses[hash]) {
      return false;
    }
    index = this.courses[hash].indexOf(course);
    if (index >= 0) {
      return this.courses[hash].splice(index, 1);
    }
  };

  CourseManager.prototype.removeElective = function(course) {
    var c, _, _i, _len, _ref, _ref1;
    if (this.sortableCourses[course]) {
      _ref = this.sortableCourses[course].courses;
      for (_ in _ref) {
        c = _ref[_];
        console.log(c, this.sortableCourses[course]);
        this.sortableCourses[course].$elm.parent().append(c.$elm);
        this.updateCourseState(c, {
          required: false,
          elective: false
        });
      }
      this.sortableCourses[course].removeCourse(c, {
        detach: false
      });
      delete this.sortableCourses[course];
    }
    _ref1 = this.courses[course];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      c = _ref1[_i];
      c.removeButton();
    }
    return delete this.courses[course];
  };

  CourseManager.prototype.removeAllCourseInstances = function(course) {
    var c, hash, _i, _len, _ref;
    hash = BasicCourse.hashCourse(course);
    _ref = this.courses[hash];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      if (c instanceof Electives) {
        this.removeElective(course);
        break;
      }
      c.removeButton();
    }
    delete this.courses[hash];
    return delete this.sortableCourses[hash];
  };

  CourseManager.prototype.cleanupUnattachedButtons = function(course, buttonType) {
    var clean,
      _this = this;
    if (buttonType == null) {
      buttonType = CourseButton;
    }
    clean = function() {
      var c, courses, hash, k, v, _i, _len, _ref;
      if (_this.needsCleaning = false) {
        return;
      }
      _this.needsCleaning = false;
      courses = [];
      if (!course) {
        _ref = _this.courses;
        for (k in _ref) {
          v = _ref[k];
          courses = courses.concat(v);
        }
      } else {
        hash = BasicCourse.hashCourse(course);
        courses = _this.courses[hash] || [];
      }
      for (_i = 0, _len = courses.length; _i < _len; _i++) {
        c = courses[_i];
        if (c instanceof buttonType && !attachedToDom(c.elm)) {
          c.removeButton();
          _this.removeCourse(c);
        }
      }
    };
    this.needsCleaning = true;
    return window.setTimeout(clean, 1000);
  };

  CourseManager.prototype.updateElectivesButton = function(button) {
    var course, data, diff, electiveButton, hash, newCourse, _i, _len, _ref, _ref1, _ref2, _results;
    data = button.getValues();
    delete data.courses;
    _ref = this.courses[button] || [];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      electiveButton = _ref[_i];
      diff = symmetricDiffObjects(button.courses, electiveButton.courses);
      _ref1 = diff['missing'];
      for (hash in _ref1) {
        course = _ref1[hash];
        newCourse = this.createCourseButton(course, {
          clickable: true
        });
        electiveButton.addCourse(newCourse);
      }
      _ref2 = diff['excess'];
      for (hash in _ref2) {
        course = _ref2[hash];
        electiveButton.removeCourse(course);
      }
      _results.push(electiveButton.update(data));
    }
    return _results;
  };

  CourseManager.prototype.selectCourse = function(course) {
    var c, hash, selectedCourse, stateButtons, _ref,
      _this = this;
    if (!course) {
      return;
    }
    selectedCourse = null;
    _ref = this.sortableCourses;
    for (hash in _ref) {
      c = _ref[hash];
      if (c.state.selected) {
        c.setState({
          selected: false
        });
      }
      if (c.subject === (course != null ? course.subject : void 0) && c.number === (course != null ? course.number : void 0)) {
        c.setState({
          selected: true
        });
        selectedCourse = c;
      }
      this.updateCourseState(c, c.state, {
        updatePrereqs: false
      });
    }
    if (!selectedCourse) {
      return;
    }
    if (selectedCourse instanceof BasicCourse) {
      stateButtons = this.sortableCoursesStateButtons[selectedCourse];
      if (!stateButtons) {
        stateButtons = this.createCourseStateButton(selectedCourse);
      }
      $('.course-info .course-name .course-number').html(selectedCourse.hash);
      $('.course-info .course-name .course-title').html(titleCaps(('' + selectedCourse.data.title).toLowerCase()));
      $('.course-info .course-state').children().detach();
      $('.course-info .course-state').html(stateButtons.elm);
      $('.course-info .prereq-area').html(PrereqUtils.prereqsToDivs(stateButtons.prereqs, this));
      $('.course-info .terms-area').html(CourseUtils.historyToDivs(selectedCourse.getTermsOffered()));
      window.setTimeout((function() {
        return $('#dot').val(_this.createDotGraph());
      }), 0);
      return this.cleanupUnattachedButtons();
    }
  };

  CourseManager.prototype.createCourseButton = function(course, ops) {
    var updateCourse,
      _this = this;
    if (ops == null) {
      ops = {};
    }
    if (this.courseData[course]) {
      course = new CourseButton(this.courseData[course], true);
    } else {
      course = new CourseButton(course);
      updateCourse = function() {
        if (!_this.courseData[course]) {
          if (course.elm) {
            course.$elm.addClass('defunct');
          }
          return;
        }
        course.update(_this.courseData[course]);
        course.setTooltip(titleCaps(course.data.title));
        return course.wasSynced = true;
      };
      this.loadSubjectData(course.subject, updateCourse);
    }
    if (ops.clickable) {
      this.makeCourseButtonClickable(course, ops);
    }
    if (ops.draggable) {
      this.makeCourseButtonDraggable(course, ops);
    }
    this.addCourse(course);
    this.initButtonState(course);
    return course;
  };

  CourseManager.prototype.makeCourseButtonClickable = function(button, ops) {
    var _this = this;
    if (ops == null) {
      ops = {};
    }
    if (ops.selectable) {
      button.selectable = true;
      button.$elm.attr({
        tabindex: 1
      });
      button.$elm.focus(function() {
        if (!this.course.state.selected) {
          return this.course.$elm.trigger('click');
        }
      });
      button.$elm.keydown(function(event) {
        var i, myIndex, node, self, siblings, sibs, _i, _len;
        self = event.currentTarget;
        siblings = event.currentTarget.parentNode.childNodes;
        myIndex = null;
        for (i = _i = 0, _len = siblings.length; _i < _len; i = ++_i) {
          node = siblings[i];
          if (node === self) {
            myIndex = i;
          }
        }
        sibs = {};
        if (myIndex + 1 < siblings.length) {
          sibs.right = siblings[myIndex + 1];
        }
        if (myIndex - 1 >= 0) {
          sibs.left = siblings[myIndex - 1];
        }
        switch (event.keyCode) {
          case 37:
            if (sibs.left) {
              return $(sibs.left).focus();
            }
            break;
          case 38:
            return '';
          case 39:
            if (sibs.right) {
              return $(sibs.right).focus();
            }
            break;
          case 40:
            return '';
          case 32:
          case 13:
            return $(self).click();
        }
      });
    }
    return $(button.getButton()).click(function(evt) {
      var newState;
      if ($(evt.currentTarget).hasClass('defunct')) {
        return;
      }
      evt.stopPropagation();
      if (ops.selectable && !button.state.selected) {
        _this.selectCourse(button);
        $(evt.currentTarget).focus();
        return;
      }
      if ($(evt.currentTarget).hasClass('noclick')) {
        $(evt.currentTarget).removeClass('noclick');
        return;
      }
      newState = CourseManager.toggleState(button.state);
      if (ops.insertOnClick) {
        _this.ensureDisplayedInYearChart(button);
      }
      return _this.updateCourseState(button, newState);
    });
  };

  CourseManager.prototype.makeCourseButtonDraggable = function(button, ops) {
    if (ops == null) {
      ops = {};
    }
    return $(button.getButton()).draggable({
      containment: '#main',
      scroll: true,
      helper: 'clone',
      revert: 'invalid',
      distance: '25',
      opacity: 0.7,
      zIndex: 1000
    });
  };

  CourseManager.prototype.makeElectivesButtonDroppable = function(button, ops) {
    var _this = this;
    if (ops == null) {
      ops = {
        clone: false
      };
    }
    button.getButton();
    return button.$coursesDiv.droppable({
      greedy: true,
      hoverClass: 'highlight',
      tolerance: 'pointer',
      accept: function(ui) {
        return ui[0].course instanceof BasicCourse;
      },
      drop: function(event, ui) {
        if (!ui.draggable[0].course) {
          return false;
        }
        button.addCourse(ui.draggable[0].course);
        _this.courseMoved(ui.draggable[0].course);
        window.courseManager.selectCourse(ui.draggable[0].course);
        return _this.updateCourseState(ui.draggable[0].course, {
          required: false,
          elective: true
        });
      }
    });
  };

  CourseManager.prototype.makeElectivesButtonClickable = function(button, ops) {
    var _this = this;
    if (ops == null) {
      ops = {};
    }
    return button.$elm.click(function() {
      return _this.selectCourse(button);
    });
  };

  CourseManager.prototype.courseMoved = function(course) {
    var hash, _ref, _results;
    _ref = this.sortableCourses;
    _results = [];
    for (hash in _ref) {
      course = _ref[hash];
      if (course instanceof ElectivesButton) {
        _results.push(this.updateElectivesButton(course));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  CourseManager.prototype.createCourseStateButton = function(course) {
    var updateCourse,
      _this = this;
    if (this.courseData[course]) {
      course = new CourseStateButton(this.courseData[course], true);
    } else {
      course = new CourseStateButton(course);
      updateCourse = function() {
        if (!_this.courseData[course]) {
          throw new Error("Course " + course + " was loaded in dep. " + course.subject + ", but wasn't available");
        }
        course.update(_this.courseData[course]);
        return course.wasSynced = true;
      };
      this.loadSubjectData(course.subject, updateCourse);
    }
    this.sortableCoursesStateButtons[course] = course;
    this.makeCourseStateButtonClickable(course);
    this.addCourse(course);
    this.initButtonState(course);
    return course;
  };

  CourseManager.prototype.makeCourseStateButtonClickable = function(button) {
    var _this = this;
    return button.$elm.find('input').bind('change', function(evt) {
      var state, val;
      val = $(evt.currentTarget).parent().find('input:checked').val();
      if (!(val != null) || val === 'none') {
        state = {
          required: false,
          elective: false
        };
      }
      if (val === 'required') {
        state = {
          required: true,
          elective: false
        };
      }
      if (val === 'elective') {
        state = {
          required: false,
          elective: true
        };
      }
      return _this.updateCourseState(button, state);
    });
  };

  CourseManager.toggleState = function(state) {
    var ret;
    ret = {
      required: false,
      elective: false
    };
    if (state.required) {
      ret.elective = true;
    }
    if (state.elective) {
      ret.elective = false;
    }
    if (!(state.required || state.elective)) {
      ret.required = true;
    }
    return ret;
  };

  CourseManager.prototype.initButtonState = function(button) {
    var c, state;
    if (!this.courses[button] || this.courses[button].length === 0) {
      return;
    }
    c = this.courses[button][0];
    state = {
      required: c.state.required,
      elective: c.state.elective
    };
    return button.setState(state, {
      forceUpdate: true
    });
  };

  CourseManager.prototype.getSelectedCourses = function() {
    var hash, list, ret, _ref, _ref1, _ref2;
    ret = [];
    _ref = this.courses;
    for (hash in _ref) {
      list = _ref[hash];
      if (((_ref1 = list[0]) != null ? _ref1.state.required : void 0) || ((_ref2 = list[0]) != null ? _ref2.state.elective : void 0)) {
        ret.push(list[0]);
      }
    }
    return ret;
  };

  CourseManager.prototype.loadSubjectData = function(subject, callback, ops) {
    var ajaxArgs, doAllCallbacks, error,
      _this = this;
    if (ops == null) {
      ops = {};
    }
    this.onSubjectLoadedCallbacks[subject] = this.onSubjectLoadedCallbacks[subject] || [];
    this.onSubjectLoadedCallbacks[subject].push(callback);
    doAllCallbacks = function() {
      var func;
      while (func = _this.onSubjectLoadedCallbacks[subject].shift()) {
        func();
      }
      return _this.loadingStatus[subject] = 'loaded';
    };
    if (this.loadedSubjects[subject] && !ops.force) {
      doAllCallbacks();
      return;
    }
    if (this.loadingStatus[subject] === 'loading' && !ops.force) {
      return;
    }
    this.loadingStatus[subject] = 'loading';
    error = function(e) {
      console.log('ajax error');
      throw e;
    };
    ajaxArgs = {
      url: "course_data/" + subject + ".json",
      dataType: 'json',
      success: this.courseDataLoaded,
      error: [
        (function() {
          return _this.loadingStatus[subject] = 'failed';
        }), ops.error || error
      ],
      complete: doAllCallbacks
    };
    return $.ajax(ajaxArgs);
  };

  CourseManager.prototype.courseDataLoaded = function(data, textState, jsXHR) {
    var c, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = data.length; _i < _len; _i++) {
      c = data[_i];
      this.courseData[BasicCourse.hashCourse(c)] = c;
      _results.push(this.loadedSubjects[c.subject] = true);
    }
    return _results;
  };

  CourseManager.prototype.showCoursesOfSubject = function(subject, ops) {
    var showCourses,
      _this = this;
    if (ops == null) {
      ops = {};
    }
    showCourses = function() {
      var course, hash, _ref, _results;
      _ref = _this.sortableCourses;
      _results = [];
      for (hash in _ref) {
        course = _ref[hash];
        if (course.subject === subject) {
          _results.push(course.$elm.show(ops.animate));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    if (this.loadedSubjects[subject]) {
      this.populateYearChartWithSubject(subject, ops);
      showCourses();
    } else {
      ops = dupObject(ops);
      ops.recursionDepth = (ops.recursionDepth || 0) + 1;
      if (ops.recursionDepth < 10) {
        this.loadSubjectData(subject, (function() {
          return _this.showCoursesOfSubject(subject, ops);
        }), ops);
      } else {
        if (ops.error) {
          ops.error();
        }
        console.log(Error("Reached maximum recusion depth when loading " + subject));
      }
    }
  };

  CourseManager.prototype.hideCoursesOfSubject = function(subject, ops) {
    var course, hash, _ref;
    if (ops == null) {
      ops = {};
    }
    _ref = this.sortableCourses;
    for (hash in _ref) {
      course = _ref[hash];
      if (course.subject === subject && course.state.required === false && course.state.elective === false) {
        if (course.elm) {
          course.$elm.hide(ops.animate);
        }
      }
    }
  };

  CourseManager.prototype.hideCourse = function(course, ops) {
    var hash, _ref;
    if (ops == null) {
      ops = {};
    }
    hash = BasicCourse.hashCourse(course);
    if (this.sortableCourses[hash]) {
      course = this.sortableCourses[hash];
      if (course.state.required === false && course.state.elective === false) {
        return (_ref = course.$elm) != null ? _ref.hide(ops.animate) : void 0;
      }
    }
  };

  CourseManager.prototype.populateYearChartWithSubject = function(subject, ops) {
    var container, course, data, hash, leadingNumber, list, year, years, _i, _j, _len, _len1, _ref, _ref1;
    years = {};
    _ref = this.courseData;
    for (hash in _ref) {
      data = _ref[hash];
      if (data.subject === subject && !this.sortableCourses[hash]) {
        leadingNumber = data.number.charAt(0);
        years[leadingNumber] = years[leadingNumber] || [];
        years[leadingNumber].push(data);
      }
    }
    _ref1 = ['1', '2', '3', '4'];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      year = _ref1[_i];
      list = years[year] || [];
      list.sort();
      container = $(".year" + year + " .courses");
      for (_j = 0, _len1 = list.length; _j < _len1; _j++) {
        data = list[_j];
        course = this.createCourseButton(data, {
          clickable: true,
          selectable: true,
          draggable: true
        });
        this.sortableCourses[course] = course;
        container.append(course.getButton());
        if (ops.animate) {
          course.$elm.hide();
          course.$elm.show(ops.animate);
        }
      }
    }
  };

  CourseManager.prototype.ensureDisplayedInYearChart = function(course, ops) {
    var hash, leadingNumber, _ref, _ref1,
      _this = this;
    if (ops == null) {
      ops = {};
    }
    hash = BasicCourse.hashCourse(course);
    if (!this.courseData[hash] && this.loadedSubjects[course.subject]) {
      if (ops.error) {
        ops.error();
      }
      throw new Error("" + hash + " cannot be loaded.  Does not appear to exist...");
    }
    if (!this.courseData[hash]) {
      this.loadSubjectData(course.subject, (function() {
        return _this.ensureDisplayedInYearChart(course, ops);
      }), ops);
      return;
    }
    if (this.sortableCourses[hash]) {
      if (ops.state) {
        this.updateCourseState(course, ops.state);
      }
      if (ops.year != null) {
        $(".year" + ops.year + " .courses").append(this.sortableCourses[hash].getButton());
      }
      if (ops.load) {
        ops.load(this.sortableCourses[hash]);
      }
      this.sortableCourses[hash].$elm.show(ops.animate);
      return;
    }
    leadingNumber = this.courseData[hash].number.charAt(0);
    if (leadingNumber < '1') {
      leadingNumber = '1';
    }
    if (leadingNumber > '4') {
      leadingNumber = '4';
    }
    if (ops.year != null) {
      leadingNumber = ops.year;
    }
    course = this.createCourseButton(this.courseData[hash], {
      clickable: true,
      selectable: true,
      draggable: true
    });
    this.sortableCourses[course] = course;
    $(".year" + leadingNumber + " .courses").append(course.getButton());
    if (ops.state) {
      this.updateCourseState(course, ops.state);
    }
    if (ops.load) {
      ops.load(course);
    }
    if (ops.animate) {
      if ((_ref = course.$elm) != null) {
        _ref.hide();
      }
      return (_ref1 = course.$elm) != null ? _ref1.show(ops.animate) : void 0;
    }
  };

  CourseManager.prototype.showUnmetPrereqs = function() {
    var activeCourses, course, div, hash, prereqs, _ref;
    activeCourses = [];
    _ref = this.sortableCourses;
    for (hash in _ref) {
      course = _ref[hash];
      if (course.state.required || course.state.elective) {
        activeCourses.push(course);
      }
    }
    prereqs = PrereqUtils.computePrereqTree(activeCourses, activeCourses);
    div = PrereqUtils.prereqsToDivs(prereqs, this);
    return $('#unmet-prereq-list').html(div);
  };

  CourseManager.prototype.createDotGraph = function() {
    this.updateGraphState();
    return this.graphState.toDot();
  };

  return CourseManager;

})();

/*
# Utility functions for dealing with lists of courses and their prereqs
*/


CourseUtils = {
  historyToDivs: function(hist) {
    var ret, term, _i, _len, _ref;
    if (hist == null) {
      hist = {};
    }
    ret = "";
    _ref = ['fall', 'spring', 'summer'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      term = _ref[_i];
      if (hist[term]) {
        ret += "<div class='availability " + term + "'>" + (titleCaps(term)) + "</div>";
      }
    }
    return ret || "<div class='notoffered'>Hasn't been offered in the last four years</div>";
  }
};

PrereqUtils = {
  prereqsToString: function(prereq) {
    var p;
    if (!(prereq != null)) {
      return "";
    }
    if (prereq.subject) {
      return Course.hashCourse(prereq);
    }
    if (prereq.op) {
      if (typeof prereq.op === 'string') {
        return "(" + ((function() {
          var _i, _len, _ref, _results;
          _ref = prereq.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            _results.push(PrereqUtils.prereqsToString(p));
          }
          return _results;
        })()).join(" " + prereq.op + " ") + ")";
      } else {
        return "";
      }
    }
  },
  prunePrereqs: function(prereq, courses) {
    var course, prunedBranch, ret, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (!(prereq != null)) {
      throw new Error("Yikes.  We errored while pruning the prereqs!");
    }
    ret = {
      op: 'and',
      data: []
    };
    if (prereq.subject) {
      if (courses.indexOf(BasicCourse.hashCourse(prereq)) === -1) {
        ret.data.push(prereq);
      }
    }
    switch (prereq.op) {
      case 'or':
        ret.op = 'or';
        _ref = prereq.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          course = _ref[_i];
          prunedBranch = PrereqUtils.prunePrereqs(course, courses);
          if (((_ref1 = prunedBranch.data) != null ? _ref1.length : void 0) === 0) {
            return {
              op: 'and',
              data: []
            };
          }
          ret.data.push(prunedBranch);
        }
        break;
      case 'and':
        _ref2 = prereq.data;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          course = _ref2[_j];
          prunedBranch = PrereqUtils.prunePrereqs(course, courses);
          if (((_ref3 = prunedBranch.data) != null ? _ref3.length : void 0) !== 0) {
            ret.data.push(prunedBranch);
          }
        }
    }
    return ret;
  },
  simplifyPrereqs: function(prereq) {
    var removeParen;
    removeParen = function(prereq) {
      var p;
      if (!(prereq.data != null)) {
        return prereq;
      }
      if (prereq.data.length === 1) {
        return removeParen(prereq.data[0]);
      }
      return {
        op: prereq.op,
        data: (function() {
          var _i, _len, _ref, _results;
          _ref = prereq.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            _results.push(removeParen(p));
          }
          return _results;
        })()
      };
    };
    return removeParen(prereq);
  },
  flattenPrereqs: function(prereq) {
    var c, ret, _i, _len, _ref;
    if (prereq != null ? prereq.subject : void 0) {
      return [prereq];
    }
    if (prereq != null ? prereq.op : void 0) {
      ret = [];
      _ref = prereq.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        ret = ret.concat(PrereqUtils.flattenPrereqs(c));
      }
      return ret;
    }
    return [];
  },
  prereqsToDivs: function(prereq, manager) {
    var course, courseElm, divs, elm, number, prereqsStr, prereqsToDivs, subject, _i, _len, _ref;
    prereqsToDivs = function(prereq) {
      var hash, p;
      if (!(prereq != null)) {
        return "";
      }
      if (prereq.subject) {
        hash = BasicCourse.hashCourse(prereq);
        return "<course id='" + hash + "' subject='" + prereq.subject + "' number='" + prereq.number + "'>" + hash + "</course>";
      }
      if (prereq.op) {
        if (typeof prereq.op === 'string') {
          return ("<ul class='prereq-tree prereq-" + prereq.op + "'><li class='prereq-tree prereq-" + prereq.op + "'>") + ((function() {
            var _i, _len, _ref, _results;
            _ref = prereq.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              p = _ref[_i];
              _results.push(prereqsToDivs(p));
            }
            return _results;
          })()).join("</li><li class='prereq-tree prereq-" + prereq.op + "'>") + "</ul>";
        } else {
          return "";
        }
      }
    };
    prereqsStr = prereqsToDivs(prereq);
    if (!prereqsStr) {
      return "<div class='noprereqs'>No prerequsites</div>";
    }
    divs = $("<div>" + prereqsStr + "</div>");
    if (!manager) {
      return divs;
    }
    _ref = divs.find('course');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      subject = elm.getAttribute('subject');
      number = elm.getAttribute('number');
      course = manager.createCourseButton({
        subject: subject,
        number: number
      }, {
        clickable: true,
        insertOnClick: true
      });
      courseElm = course.getButton();
      elm.parentNode.replaceChild(courseElm, elm);
    }
    return divs;
  },
  computePrereqTree: function(courses, selected) {
    var course, hashify, pruned, ret, s, _i, _len, _ref;
    if (selected == null) {
      selected = [];
    }
    if (!(courses != null)) {
      throw new Error("computePrereqTree requires a list of course hashes");
    }
    hashify = function(s) {
      if (typeof s === 'string') {
        return s;
      }
      return BasicCourse.hashCourse(s);
    };
    selected = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = selected.length; _i < _len; _i++) {
        s = selected[_i];
        _results.push(hashify(s));
      }
      return _results;
    })();
    ret = {
      op: 'and',
      data: []
    };
    for (_i = 0, _len = courses.length; _i < _len; _i++) {
      course = courses[_i];
      if (typeof course === 'string') {
        throw new Error("cannot computePrereqTree with courses given as strings");
      }
      if (!course.wasSynced) {
        throw new Error("attempting to compute prereqs of " + course + " when data isn't synced");
      }
      if (course.prereqs != null) {
        pruned = PrereqUtils.prunePrereqs(course.prereqs, selected);
        if (((_ref = pruned.data) != null ? _ref.length : void 0) > 0) {
          pruned.requiredBy = course;
          ret.data.push(pruned);
        }
      }
    }
    ret = PrereqUtils.simplifyPrereqs(ret);
    return ret;
  }
};

/*
# Parent class of various course buttons
*/


BasicCourse = (function() {

  BasicCourse.hashCourse = function(course) {
    if (typeof course === 'string') {
      return course;
    }
    return "" + course.subject + " " + course.number;
  };

  function BasicCourse(data, synced) {
    var _ref;
    this.data = data;
    if (synced == null) {
      synced = false;
    }
    this.hash = BasicCourse.hashCourse(this.data);
    _ref = this.data, this.subject = _ref.subject, this.number = _ref.number, this.prereqs = _ref.prereqs;
    this.state = {
      required: false,
      elective: false,
      selected: false,
      prereq: false
    };
    this.wasSynced = synced;
  }

  BasicCourse.prototype.toString = function() {
    return this.hash;
  };

  BasicCourse.prototype.update = function(data) {
    this.data = data;
    return this.prereqs = this.data.prereqs;
  };

  BasicCourse.prototype.getTermsOffered = function() {
    var k, month, ret;
    ret = {};
    for (k in this.data.terms_offered || {}) {
      month = k.slice(-2);
      switch (month) {
        case '09':
          ret['fall'] = (ret['fall'] || 0) + 1;
          break;
        case '01':
          ret['spring'] = (ret['spring'] || 0) + 1;
          break;
        case '05':
          ret['summer'] = (ret['summer'] || 0) + 1;
      }
    }
    return ret;
  };

  BasicCourse.prototype.setState = function(state) {
    var ret, s, v;
    ret = {};
    for (s in state) {
      v = state[s];
      if (this.state[s] !== v) {
        ret[s] = v;
        this.state[s] = v;
      }
    }
    return ret;
  };

  return BasicCourse;

})();

/*
# Rectangular button that displays a course's number and state
*/


CourseButton = (function(_super) {

  __extends(CourseButton, _super);

  function CourseButton(data) {
    CourseButton.__super__.constructor.call(this, data);
    this.getButton();
  }

  CourseButton.prototype.setState = function(state, ops) {
    var changedState, s, v;
    if (ops == null) {
      ops = {};
    }
    changedState = CourseButton.__super__.setState.call(this, state);
    if (!ops.forceUpdate) {
      state = changedState;
    }
    if (!this.elm) {
      return state;
    }
    for (s in state) {
      v = state[s];
      if (v) {
        this.$elm.addClass(s);
      } else {
        this.$elm.removeClass(s);
      }
    }
    return state;
  };

  CourseButton.prototype.getButton = function() {
    if (this.elm) {
      return this.elm;
    }
    this.$elm = $("<div class='course' subject='" + this.subject + "' number='" + this.number + "'><div class='annotation'></div><div class='number'>" + this.subject + " " + this.number + "</div></div>");
    this.setTooltip(titleCaps(this.data.title));
    this.$elm.disableSelection();
    this.elm = this.$elm[0];
    this.elm.course = this;
    this.setState(this.state);
    return this.elm;
  };

  CourseButton.prototype.removeButton = function() {
    if (!this.elm) {
      return;
    }
    this.elm.course = null;
    this.$elm.remove();
    return this.elm = this.$elm = null;
  };

  CourseButton.prototype.setTooltip = function(tip) {
    if (tip) {
      return this.$elm.attr({
        title: tip
      });
    }
  };

  return CourseButton;

})(BasicCourse);

/*
# Set of three toggle buttons that change (and reflect) the state of a course
*/


CourseStateButton = (function(_super) {

  __extends(CourseStateButton, _super);

  function CourseStateButton(data) {
    CourseStateButton.__super__.constructor.call(this, data);
    this.getButton();
  }

  CourseStateButton.prototype.getButton = function() {
    if (this.elm) {
      return this.elm;
    }
    this.$elm = $("<div class='course-status'>\n        <input type='radio' name='state' value='none' id='course-notincluded' /><label for='course-notincluded'>Not Included</label>\n        <input type='radio' name='state' value='required' id='course-required' /><label for='course-required'>Required</label>\n        <input type='radio' name='state' value='elective' id='course-elective' /><label for='course-elective'>Elective</label>\n</div>");
    this.$elm.buttonset();
    return this.elm = this.$elm[0];
  };

  CourseStateButton.prototype.setState = function(state, ops) {
    var changedState,
      _this = this;
    if (ops == null) {
      ops = {};
    }
    changedState = CourseStateButton.__super__.setState.call(this, state);
    if (!ops.forceUpdate) {
      state = changedState;
    }
    if ((!this.elm || Object.keys(state).length === 0) && !ops.forceUpdate) {
      return state;
    }
    this.$elm.find('input').attr('checked', false);
    if (this.state.required) {
      this.$elm.find('input[value=required]').attr('checked', true);
    } else if (this.state.elective) {
      this.$elm.find('input[value=elective]').attr('checked', true);
    } else {
      this.$elm.find('input[value=none]').attr('checked', true);
    }
    window.setTimeout((function() {
      return _this.$elm.buttonset('refresh');
    }), 0);
    return state;
  };

  CourseStateButton.prototype.removeButton = function() {
    if (!this.elm) {
      return;
    }
    this.elm.course = null;
    this.$elm.remove();
    return this.elm = this.$elm = null;
  };

  return CourseStateButton;

})(BasicCourse);

/*
# Holds a group of courses
*/


Electives = (function() {

  function Electives(data) {
    this.title = data.title, this.requirements = data.requirements, this.number = data.number;
    this.courses = dupObject(data.courses || {});
    this.state = {};
    if (!(this.requirements != null)) {
      this.requirements = {
        units: 1.5,
        unitLabel: 'units'
      };
    }
    this.subject = this.title;
    this.number = this.number || Math.random().toFixed(8);
    this.hash = BasicCourse.hashCourse(this);
  }

  Electives.prototype.toString = function() {
    return this.hash;
  };

  Electives.prototype.addCourse = function(course) {
    return this.courses[course] = course;
  };

  Electives.prototype.removeCourse = function(course) {
    return delete this.courses[course];
  };

  Electives.prototype.setState = function(state) {
    var ret, s, v;
    ret = {};
    for (s in state) {
      v = state[s];
      if (this.state[s] !== v) {
        ret[s] = v;
        this.state[s] = v;
      }
    }
    return ret;
  };

  Electives.prototype.update = function(data) {
    var k, v;
    for (k in data) {
      v = data[k];
      this[k] = v;
    }
    return this.hash = BasicCourse.hashCourse(this);
  };

  Electives.prototype.getValues = function() {
    return {
      title: this.title,
      requirements: this.requirements,
      number: this.number,
      courses: this.courses
    };
  };

  return Electives;

})();

ElectivesButton = (function(_super) {

  __extends(ElectivesButton, _super);

  function ElectivesButton(data, manager) {
    this.manager = manager;
    ElectivesButton.__super__.constructor.call(this, data);
    this.selectable = true;
    this.getButton();
  }

  ElectivesButton.prototype.setState = function(state, ops) {
    var changedState, s, v;
    if (ops == null) {
      ops = {};
    }
    changedState = ElectivesButton.__super__.setState.call(this, state);
    if (!ops.forceUpdate) {
      state = changedState;
    }
    if (!this.elm) {
      return state;
    }
    for (s in state) {
      v = state[s];
      if (v) {
        this.$elm.addClass(s);
      } else {
        this.$elm.removeClass(s);
      }
    }
    return state;
  };

  ElectivesButton.prototype.getButton = function() {
    var course, hash, _ref;
    if (this.elm) {
      return this.elm;
    }
    this.$elm = $("<div class=\"electives-block\" subject=\"" + this.subject + "\" number=\"" + this.number + "\">\n	<div class=\"title\">" + this.title + "</div>\n	<div class=\"requirement\">At least " + this.requirements.units + " " + this.requirements.unitLabel + "</div>\n	<div class=\"courses-list\"><span class=\"droptext\">Drop Here to Add Courses</span></div>\n</div>");
    this.elm = this.$elm[0];
    this.elm.course = this;
    this.$coursesDiv = this.$elm.find('.courses-list');
    _ref = this.courses;
    for (hash in _ref) {
      course = _ref[hash];
      this.addCourse(course);
    }
    return this.elm;
  };

  ElectivesButton.prototype.addCourse = function(course) {
    ElectivesButton.__super__.addCourse.call(this, course);
    if (!course.elm) {
      course = this.courses[BasicCourse.hashCourse(course)] = new CourseButton(course.data);
    }
    this.$coursesDiv.append(course.elm);
    return this.updateDropTextVisibility();
  };

  ElectivesButton.prototype.removeCourse = function(course, ops) {
    var $elm;
    if (ops == null) {
      ops = {
        detach: true
      };
    }
    if (ops.detach) {
      $elm = this.courses[BasicCourse.hashCourse(course)].$elm;
      if ($elm) {
        $elm.detach();
      }
    }
    ElectivesButton.__super__.removeCourse.call(this, course);
    return this.updateDropTextVisibility();
  };

  ElectivesButton.prototype.removeButton = function(ops) {
    var course;
    if (ops == null) {
      ops = {
        detach: true
      };
    }
    if (!this.elm) {
      return;
    }
    for (course in this.courses) {
      this.removeCourse(course, ops);
    }
    this.elm.course = null;
    this.$elm.remove();
    this.elm = this.$elm = null;
  };

  ElectivesButton.prototype.update = function(data) {
    var elm, _i, _len, _ref;
    ElectivesButton.__super__.update.call(this, data);
    this.courses = {};
    _ref = this.$elm.find('.courses-list').children();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      if (elm.course) {
        this.courses[elm.course] = elm.course;
      }
    }
    this.$elm.find('.title').html(this.title);
    this.$elm.find('.requirement').html("At least " + this.requirements.units + " " + this.requirements.unitLabel);
    this.$elm.attr({
      subject: this.subject,
      number: this.number
    });
    return this.updateDropTextVisibility();
  };

  ElectivesButton.prototype.updateDropTextVisibility = function() {
    if (Object.keys(this.courses).length === 0) {
      return this.$elm.find('.droptext').show();
    } else {
      return this.$elm.find('.droptext').hide();
    }
  };

  return ElectivesButton;

})(Electives);

ElectivesButtonEditor = (function(_super) {

  __extends(ElectivesButtonEditor, _super);

  function ElectivesButtonEditor(data, manager) {
    this.manager = manager;
    ElectivesButtonEditor.__super__.constructor.call(this, data);
    this.selectable = true;
    this.getButton();
  }

  ElectivesButtonEditor.prototype.setState = function(state, ops) {
    var changedState, s, v;
    if (ops == null) {
      ops = {};
    }
    changedState = ElectivesButtonEditor.__super__.setState.call(this, state);
    if (!ops.forceUpdate) {
      state = changedState;
    }
    if (!this.elm) {
      return state;
    }
    for (s in state) {
      v = state[s];
      if (v) {
        this.$elm.addClass(s);
      } else {
        this.$elm.removeClass(s);
      }
    }
    return state;
  };

  ElectivesButtonEditor.prototype.getButton = function() {
    var course, hash, update, _ref,
      _this = this;
    if (this.elm) {
      return this.elm;
    }
    this.$elm = $("<li class='elective-editable'>\n    <button class='delete-elective' title='Delete Electives Block'></button>\n    <div class='title'>Title: <input type='text' value='" + this.title + "' class='ui-state-default ui-combobox-input ui-widget ui-widget-content ui-corner-all'></input></div>\n    <div class='requirements'>At least <input type='text' value='" + this.requirements.units + "' class='ui-state-default ui-combobox-input ui-widget ui-widget-content ui-corner-all'></input> " + this.requirements.unitLabel + "</div>\n    Elective Courses: <div class='dropbox courses-list'><span class='droptext'>Use the Year Chart to Add Courses</span></div>\n</li>");
    this.elm = this.$elm[0];
    this.$coursesDiv = this.$elm.find('.courses-list');
    this.$elm.find('.delete-elective').button({
      icons: {
        primary: 'ui-icon-trash'
      },
      text: false
    });
    this.$elm.find('.delete-elective').click(function() {
      if (_this.manager) {
        return _this.manager.removeElective(_this);
      }
    });
    _ref = this.courses;
    for (hash in _ref) {
      course = _ref[hash];
      this.addCourse(course);
    }
    update = function(event) {
      if (_this.manager) {
        return _this.manager.updateElectivesButton(_this);
      }
    };
    this.$elm.find('.title input').change(update);
    this.$elm.find('.requirements input').change(update);
    return this.elm;
  };

  ElectivesButtonEditor.prototype.addCourse = function(course) {
    ElectivesButtonEditor.__super__.addCourse.call(this, course);
    if (!course.elm) {
      course = this.courses[BasicCourse.hashCourse(course)] = new CourseButton(course.data);
    }
    this.$coursesDiv.append(course.elm);
    return this.updateDropTextVisibility();
  };

  ElectivesButtonEditor.prototype.removeCourse = function(course, ops) {
    var $elm;
    if (ops == null) {
      ops = {
        detach: true
      };
    }
    if (ops.detach) {
      $elm = this.courses[BasicCourse.hashCourse(course)].$elm;
      if ($elm) {
        $elm.detach();
      }
    }
    ElectivesButtonEditor.__super__.removeCourse.call(this, course);
    return this.updateDropTextVisibility();
  };

  ElectivesButtonEditor.prototype.removeButton = function(ops) {
    var course;
    if (ops == null) {
      ops = {
        detach: true
      };
    }
    if (!this.elm) {
      return;
    }
    for (course in this.courses) {
      this.removeCourse(course, ops);
    }
    this.elm.course = null;
    this.$elm.remove();
    this.elm = this.$elm = null;
  };

  ElectivesButtonEditor.prototype.update = function(data) {
    ElectivesButtonEditor.__super__.update.call(this, data);
    this.$elm.find('.title input').val(this.title);
    this.$elm.find('.requirements .input').val(this.requirements.units);
    return this.updateDropTextVisibility();
  };

  ElectivesButtonEditor.prototype.getValues = function() {
    this.title = this.$elm.find('.title input').val();
    this.requirements.units = this.$elm.find('.requirements input').val();
    return ElectivesButtonEditor.__super__.getValues.call(this);
  };

  ElectivesButtonEditor.prototype.updateDropTextVisibility = function() {
    if (Object.keys(this.courses).length === 0) {
      return this.$elm.find('.droptext').show();
    } else {
      return this.$elm.find('.droptext').hide();
    }
  };

  return ElectivesButtonEditor;

})(Electives);

/*
# Class to hold the state of the current graph.  This object
# can be used for loading and saving and will preserve
# invisible and custom-added edges.
*/


Graph = (function() {

  function Graph() {
    this.dirty = true;
    this.nodes = {};
    this.edges = {};
    this.clusters = {};
  }

  Graph.prototype.toJSON = function(stringify) {
    var c, cluster, edge, elective, node, ret, _, _base, _ref, _ref1, _ref2, _ref3, _ref4;
    if (stringify == null) {
      stringify = true;
    }
    ret = {
      nodes: [],
      edges: [],
      clusters: [],
      title: this.title
    };
    _ref = this.nodes;
    for (_ in _ref) {
      node = _ref[_];
      ret.nodes.push({
        course: {
          subject: node.course.subject,
          number: node.course.number,
          state: node.course.state,
          data: {
            title: titleCaps((_ref1 = node.course.data) != null ? _ref1.title : void 0),
            description: ((_ref2 = node.course.data) != null ? _ref2.description : void 0) || '',
            terms_offered: (typeof (_base = node.course).getTermsOffered === "function" ? _base.getTermsOffered() : void 0) || {}
          }
        },
        year: node.year
      });
    }
    _ref3 = this.edges;
    for (_ in _ref3) {
      edge = _ref3[_];
      ret.edges.push({
        edge: ['' + edge.edge[0], '' + edge.edge[1]],
        properties: edge.properties || {}
      });
    }
    _ref4 = this.clusters;
    for (_ in _ref4) {
      cluster = _ref4[_];
      elective = cluster.cluster;
      ret.clusters.push({
        cluster: {
          subject: elective.subject,
          number: elective.number,
          title: elective.title,
          requirements: {
            units: elective.requirements.units,
            unitLabel: elective.requirements.unitLabel
          }
        },
        year: cluster.year,
        courses: (function() {
          var _i, _len, _ref5, _results;
          _ref5 = cluster.courses;
          _results = [];
          for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
            c = _ref5[_i];
            _results.push({
              subject: c.subject,
              number: c.number
            });
          }
          return _results;
        })()
      });
    }
    if (stringify) {
      return JSON.stringify(ret);
    }
    return ret;
  };

  Graph.prototype.fromJSON = function(str, ops) {
    var cluster, data, edge, hash, node, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (ops == null) {
      ops = {};
    }
    this.dirty = true;
    data = JSON.parse(str);
    _ref = data.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      hash = BasicCourse.hashCourse(node.course);
      this.nodes[hash] = node;
    }
    _ref1 = data.edges;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      edge = _ref1[_j];
      this.edges[edge.edge] = edge;
    }
    _ref2 = data.clusters;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      cluster = _ref2[_k];
      hash = BasicCourse.hashCourse(cluster.cluster);
      this.clusters[hash] = cluster;
    }
    this.title = data.title;
    return this;
  };

  Graph.prototype.clearAll = function() {
    this.dirty = true;
    this.nodes = {};
    this.edges = {};
    return this.clusters = {};
  };

  Graph.prototype.addNode = function(course, ops) {
    if (ops == null) {
      ops = {};
    }
    this.dirty = true;
    return this.nodes[course] = {
      course: course,
      year: ops.year,
      term: ops.term
    };
  };

  Graph.prototype.removeNode = function(course) {
    this.dirty = true;
    return delete this.nodes[course];
  };

  Graph.prototype.addEdge = function(edge, ops) {
    if (ops == null) {
      ops = {};
    }
    this.dirty = true;
    return this.edges[edge] = {
      edge: edge,
      properties: ops.properties || {}
    };
  };

  Graph.prototype.removeEdge = function(edge) {
    this.dirty = true;
    return delete this.edges[edge];
  };

  Graph.prototype.pruneOrphanedEdges = function() {
    var edge, hash, _ref, _results;
    _ref = this.edges;
    _results = [];
    for (hash in _ref) {
      edge = _ref[hash];
      if ((!this.nodes[edge.edge[0]]) || (!this.nodes[edge.edge[0]])) {
        _results.push(this.removeEdge(hash));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Graph.prototype.generateEdges = function(ops) {
    var c, course, edge, hash, i, j, list, mat, node, numDeleted, optimizedMat, originalEdges, p, prereqs, row, v, _, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (ops == null) {
      ops = {
        optimize: true
      };
    }
    originalEdges = this.edges;
    this.edges = {};
    _ref = this.nodes;
    for (_ in _ref) {
      node = _ref[_];
      course = node.course;
      if (course.prereqs != null) {
        prereqs = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = PrereqUtils.flattenPrereqs(course.prereqs);
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            c = _ref1[_i];
            _results.push(BasicCourse.hashCourse(c));
          }
          return _results;
        })();
        for (_i = 0, _len = prereqs.length; _i < _len; _i++) {
          p = prereqs[_i];
          if (this.nodes[p]) {
            edge = [p, BasicCourse.hashCourse(course)];
            this.edges[edge] = {
              edge: edge,
              properties: {
                autoGenerated: true
              }
            };
          }
        }
      }
    }
    if (ops.optimize) {
      numDeleted = 0;
      _ref1 = this._generateAdjacencyMatrix(), mat = _ref1.mat, list = _ref1.list;
      optimizedMat = this._optimizeEdges(mat);
      for (i = _j = 0, _len1 = mat.length; _j < _len1; i = ++_j) {
        row = mat[i];
        for (j = _k = 0, _len2 = row.length; _k < _len2; j = ++_k) {
          v = row[j];
          if (v) {
            if (!optimizedMat[i][j]) {
              numDeleted += 1;
              edge = [list[i], list[j]];
              delete this.edges[edge];
            }
          }
        }
      }
      console.log(numDeleted, 'edges deleted');
    }
    for (hash in originalEdges) {
      edge = originalEdges[hash];
      if (!((_ref2 = edge.properties) != null ? _ref2.autogenerated : void 0)) {
        this.edges[hash] = edge;
      }
    }
    return this.edges;
  };

  Graph.prototype.toDot = function() {
    var cluster, course, courses, createAnonymousSubgraph, edge, edgeObj, elective, graph, hash, i, index, labelWidth, levels, list, marker, mat, node, prevMarker, rankSubgraph, subgraph, term, termClust, termSubgraph, termSubgraphs, year, yearSubgraph, yearSubgraphs, _, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
    createAnonymousSubgraph = function(parent) {
      var subgraph;
      subgraph = graph.addSubgraph(null, parent);
      subgraph.attrs['rank'] = 'same';
      return subgraph;
    };
    graph = new DotGraph();
    graph.rootGraph.type = 'digraph';
    graph.rootGraph.attrs['rankdir'] = 'LR';
    if (this.title) {
      graph.rootGraph.attrs['label'] = "" + this.title;
      graph.rootGraph.attrs['_title'] = "" + this.title;
      graph.rootGraph.attrs['labelloc'] = "top";
      graph.rootGraph.attrs['labelfontsize'] = 30;
    }
    yearSubgraphs = {};
    termSubgraphs = {};
    for (year = _i = 1; _i <= 4; year = ++_i) {
      yearSubgraph = graph.addSubgraph("year" + year);
      yearSubgraphs[year] = yearSubgraph;
      termSubgraphs[year] = {};
      for (term = _j = 1; _j <= 3; term = ++_j) {
        termSubgraph = createAnonymousSubgraph(yearSubgraph);
        termSubgraph.attrs['rank'] = 'same';
        termSubgraphs[year][term] = termSubgraph;
        marker = "YEAR" + year + "TERM" + term;
        termSubgraph.nodes[marker] = true;
        graph.nodes[marker] = {
          attrs: {
            _year: year,
            _term: term,
            style: 'invis',
            shape: 'none',
            label: '',
            fixedsize: 'false',
            height: 0,
            width: 1
          }
        };
      }
    }
    _ref = this.edges;
    for (_ in _ref) {
      edge = _ref[_];
      edgeObj = {
        edge: edge.edge,
        attrs: {}
      };
      if (((_ref1 = edge.properties) != null ? _ref1.style : void 0) === 'invis') {
        edgeObj.attrs['style'] = 'invis';
      }
      if ((_ref2 = edge.properties) != null ? _ref2.coreq : void 0) {
        edgeObj.attrs['arrowhead'] = 'none';
        edgeObj.attrs['weight'] = 5;
      }
      graph.edges[edge.edge] = [edgeObj];
    }
    _ref3 = this.nodes;
    for (_ in _ref3) {
      node = _ref3[_];
      course = node.course;
      hash = BasicCourse.hashCourse(course);
      graph.nodes[hash] = {
        attrs: {
          _name: hash,
          _title: titleCaps((_ref4 = course.data) != null ? _ref4.title : void 0),
          _year: node.year,
          shape: 'box',
          style: 'rounded'
        }
      };
    }
    for (year = _k = 1; _k <= 4; year = ++_k) {
      _ref5 = this._generateAdjacencyMatrix({
        filterByYear: year
      }), mat = _ref5.mat, list = _ref5.list;
      levels = this._stratify(mat);
      for (i = _l = 0, _len = levels.length; _l < _len; i = ++_l) {
        termClust = levels[i];
        rankSubgraph = termSubgraphs[year][i + 1];
        for (_m = 0, _len1 = termClust.length; _m < _len1; _m++) {
          index = termClust[_m];
          course = list[index];
          rankSubgraph.nodes[course] = true;
        }
      }
    }
    _ref6 = this.clusters;
    for (_ in _ref6) {
      cluster = _ref6[_];
      year = cluster.year, courses = cluster.courses;
      elective = cluster.cluster;
      if (courses.length === 0) {
        subgraph = termSubgraphs[year][1];
        hash = BasicCourse.hashCourse(elective);
        graph.nodes[hash] = {
          attrs: {
            _elective: true,
            _title: "" + elective.title + " (" + elective.requirements.units + " " + elective.requirements.unitLabel + ")",
            _year: year,
            shape: 'box',
            style: 'rounded,filled',
            color: 'invis',
            fillcolor: 'gray'
          }
        };
        subgraph.nodes[elective] = true;
      } else {
        subgraph = graph.addSubgraph("cluster" + (Math.random().toFixed(8).slice(3)));
        subgraph.attrs = {
          style: 'rounded,filled',
          color: 'gray',
          label: "" + elective.title + " (" + elective.requirements.units + " " + elective.requirements.unitLabel + ")",
          _title: "" + elective.title + " (" + elective.requirements.units + " " + elective.requirements.unitLabel + ")",
          _electivesBlock: true
        };
        for (_n = 0, _len2 = courses.length; _n < _len2; _n++) {
          course = courses[_n];
          hash = BasicCourse.hashCourse(course);
          subgraph.nodes[hash] = true;
          graph.nodes[hash].attrs['color'] = 'white';
          graph.nodes[hash].attrs['style'] = 'rounded,filled';
          graph.nodes[hash].attrs['_inElectivesBlock'] = true;
        }
      }
    }
    prevMarker = null;
    for (year = _o = 1; _o <= 4; year = ++_o) {
      for (term = _p = 1; _p <= 3; term = ++_p) {
        termSubgraph = termSubgraphs[year][term];
        marker = "YEAR" + year + "TERM" + term;
        if (Object.keys(termSubgraph.nodes).length > 1 || term === 1) {
          if (prevMarker) {
            edge = [prevMarker, marker];
            graph.edges[edge] = [
              {
                edge: edge,
                attrs: {
                  style: 'invis'
                }
              }
            ];
          }
          prevMarker = marker;
        } else {
          graph.removeNode(marker);
          graph.removeSubgraph(termSubgraph);
        }
      }
    }
    _ref7 = graph.nodes;
    for (hash in _ref7) {
      node = _ref7[hash];
      if ((_ref8 = node.attrs['style']) != null ? _ref8.match(/invis/) : void 0) {
        node.attrs['label'] = '';
        continue;
      }
      node.attrs['height'] = 42 / 72;
      labelWidth = Math.max(strWidthInEn(node.attrs['_title']), strWidthInEn(node.attrs['_name']));
      node.attrs['width'] = (labelWidth * 6.0 + 20) / 72;
      node.attrs['fixedsize'] = true;
    }
    return astToStr(graph.generateAst());
  };

  Graph.prototype._generateAdjacencyMatrix = function(ops) {
    var adjacencyEntry, createRow, e, edge, n, nodeList, outEdges, ret, _, _ref, _ref1;
    if (ops == null) {
      ops = {};
    }
    adjacencyEntry = function(n) {
      if (n === 'coreq') {
        return 2;
      }
      return +(!!n);
    };
    createRow = function(e) {
      var n;
      return (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = nodeList.length; _i < _len; _i++) {
          n = nodeList[_i];
          _results.push(adjacencyEntry(e[n]));
        }
        return _results;
      })();
    };
    if (ops.filterByYear != null) {
      nodeList = (function() {
        var _results;
        _results = [];
        for (n in this.nodes) {
          if (this.nodes[n].year === ops.filterByYear) {
            _results.push(n);
          }
        }
        return _results;
      }).call(this);
    } else {
      nodeList = (function() {
        var _results;
        _results = [];
        for (n in this.nodes) {
          _results.push(n);
        }
        return _results;
      }).call(this);
    }
    outEdges = {};
    _ref = this.edges;
    for (_ in _ref) {
      e = _ref[_];
      edge = e.edge;
      outEdges[edge[0]] = outEdges[edge[0]] || {};
      outEdges[edge[0]][edge[1]] = true;
      if ((_ref1 = e.properties) != null ? _ref1.coreq : void 0) {
        outEdges[edge[0]][edge[1]] = 'coreq';
      }
    }
    ret = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = nodeList.length; _i < _len; _i++) {
        n = nodeList[_i];
        _results.push(createRow(outEdges[n] || {}));
      }
      return _results;
    })();
    if (ret.length === 0) {
      ret.push([]);
    }
    return {
      mat: ret,
      list: nodeList
    };
  };

  Graph.prototype._matrixSpan = function(mat) {
    var i, iters, size, _i;
    size = mat[0].length;
    if (size <= 1) {
      return mat;
    }
    iters = Math.ceil(Math.log(size) / Math.log(2));
    for (i = _i = 0; 0 <= iters ? _i < iters : _i > iters; i = 0 <= iters ? ++_i : --_i) {
      mat = numeric.add(numeric.dot(mat, mat), mat);
    }
    return numeric.gt(mat, 0);
  };

  Graph.prototype._optimizeEdges = function(mat) {
    var existsOtherRoute, i, j, mat_span, mat_transpose, node, nodes, predicessors, ret, span, v, _i, _j, _k, _l, _len, _len1, _len2, _ref, _results;
    ret = numeric.clone(mat);
    mat_transpose = numeric.transpose(mat);
    mat_span = this._matrixSpan(mat);
    nodes = (function() {
      _results = [];
      for (var _i = 0, _ref = mat[0].length; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    for (_j = 0, _len = nodes.length; _j < _len; _j++) {
      node = nodes[_j];
      predicessors = mat_transpose[node];
      for (i = _k = 0, _len1 = predicessors.length; _k < _len1; i = ++_k) {
        v = predicessors[i];
        if (!(v > 0 && i !== node)) {
          continue;
        }
        span = mat_span[i];
        existsOtherRoute = false;
        for (j = _l = 0, _len2 = span.length; _l < _len2; j = ++_l) {
          v = span[j];
          if (v > 0) {
            if (predicessors[j] > 0) {
              existsOtherRoute = true;
              break;
            }
          }
        }
        if (existsOtherRoute) {
          ret[i][node] = 0;
        }
      }
    }
    return ret;
  };

  Graph.prototype._stratify = function(mat, maxLevels, coreqsOnSameLevel) {
    var collapsedMat, coreqAdj, i, j, mask, oreqCol, oreqRow, rep, repMat, repRanks, reps, row, stratify, unflatten, v, val, zeroedSubmatrix, _, _i, _j, _k, _l, _len, _len1, _len2, _m, _ref, _ref1,
      _this = this;
    if (maxLevels == null) {
      maxLevels = 3;
    }
    if (coreqsOnSameLevel == null) {
      coreqsOnSameLevel = true;
    }
    if (mat[0].length === 0) {
      return [];
    }
    unflatten = function(ranks) {
      var i, levels, rank, _i, _len;
      levels = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 3; i = ++_i) {
          _results.push([]);
        }
        return _results;
      })();
      for (i = _i = 0, _len = ranks.length; _i < _len; i = ++_i) {
        rank = ranks[i];
        levels[rank].push(i);
      }
      return levels;
    };
    stratify = function(mat, maxLevels) {
      var forwardSpan, i, incrementRanks, l, level, mat_span, needUpdating, nodesOfCurrentLevel, numNodes, ranks, _i, _ref;
      numNodes = mat[0].length;
      mat_span = _this._matrixSpan(mat);
      ranks = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; 0 <= numNodes ? _i < numNodes : _i > numNodes; i = 0 <= numNodes ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      })();
      incrementRanks = function(nodes) {
        var v, _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = nodes.length; _i < _len; i = ++_i) {
          v = nodes[i];
          if (v > 0) {
            _results.push(ranks[i] += 1);
          }
        }
        return _results;
      };
      forwardSpan = function(nodes) {
        var ret, v, _i, _len;
        ret = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= numNodes ? _i < numNodes : _i > numNodes; i = 0 <= numNodes ? ++_i : --_i) {
            _results.push(false);
          }
          return _results;
        })();
        for (i = _i = 0, _len = nodes.length; _i < _len; i = ++_i) {
          v = nodes[i];
          if (v > 0) {
            numeric.oreq(ret, mat_span[i]);
          }
        }
        return ret;
      };
      for (level = _i = 0, _ref = maxLevels - 1; 0 <= _ref ? _i < _ref : _i > _ref; level = 0 <= _ref ? ++_i : --_i) {
        nodesOfCurrentLevel = (function() {
          var _j, _len, _results;
          _results = [];
          for (_j = 0, _len = ranks.length; _j < _len; _j++) {
            l = ranks[_j];
            _results.push(l === level);
          }
          return _results;
        })();
        needUpdating = forwardSpan(nodesOfCurrentLevel);
        incrementRanks(needUpdating);
      }
      return ranks;
    };
    if (!coreqsOnSameLevel) {
      return unflatten(stratify(mat, maxLevels));
    }
    zeroedSubmatrix = function(mat, mask) {
      var i, m, _i, _len;
      mat = numeric.clone(mat);
      for (i = _i = 0, _len = mask.length; _i < _len; i = ++_i) {
        m = mask[i];
        if (!m) {
          numeric.muleq(mat[i], 0);
        } else {
          numeric.muleq(mat[i], mask);
        }
      }
      return mat;
    };
    coreqAdj = numeric.clone(mat);
    coreqAdj = numeric.eq(coreqAdj, 2);
    coreqAdj = numeric.or(coreqAdj, numeric.transpose(coreqAdj));
    coreqAdj = this._matrixSpan(coreqAdj);
    mask = (function() {
      var _i, _ref, _results;
      _results = [];
      for (_ = _i = 0, _ref = coreqAdj[0].length; 0 <= _ref ? _i < _ref : _i > _ref; _ = 0 <= _ref ? ++_i : --_i) {
        _results.push(true);
      }
      return _results;
    })();
    reps = (function() {
      var _i, _ref, _results;
      _results = [];
      for (v = _i = 0, _ref = coreqAdj[0].length; 0 <= _ref ? _i < _ref : _i > _ref; v = 0 <= _ref ? ++_i : --_i) {
        _results.push(v);
      }
      return _results;
    })();
    for (i = _i = 0, _len = coreqAdj.length; _i < _len; i = ++_i) {
      row = coreqAdj[i];
      if (mask[i]) {
        for (j = _j = 0, _len1 = row.length; _j < _len1; j = ++_j) {
          val = row[j];
          if (!(i !== j && val)) {
            continue;
          }
          mask[j] = false;
          reps[j] = i;
        }
      }
    }
    oreqRow = function(mat, row1, row2) {
      return numeric.oreq(mat[row1], mat[row2]);
    };
    oreqCol = function(mat, col1, col2) {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = mat.length; _k < _len2; _k++) {
        row = mat[_k];
        _results.push(row[col1] |= row[col2]);
      }
      return _results;
    };
    collapsedMat = numeric.clone(mat);
    for (i = _k = 0, _len2 = reps.length; _k < _len2; i = ++_k) {
      rep = reps[i];
      oreqRow(collapsedMat, rep, i);
      oreqCol(collapsedMat, rep, i);
    }
    for (i = _l = 0, _ref = collapsedMat[0].length; 0 <= _ref ? _l < _ref : _l > _ref; i = 0 <= _ref ? ++_l : --_l) {
      collapsedMat[i][i] = 0;
    }
    repMat = zeroedSubmatrix(collapsedMat, mask);
    repRanks = stratify(repMat, maxLevels);
    for (i = _m = 0, _ref1 = repRanks.length; 0 <= _ref1 ? _m < _ref1 : _m > _ref1; i = 0 <= _ref1 ? ++_m : --_m) {
      repRanks[i] = repRanks[reps[i]];
    }
    return unflatten(repRanks);
  };

  return Graph;

})();

/*
# Various methods of downloading data to the users compuer so they can save it.
# Initially DownloadManager.download will try to bounce off download.php,
# a server-side script that sends the data it receives back with approprate
# headers. If this fails, it will try to use the blob API to and the
# 'download' attribute of an anchor to download the file with a suggested file name.
# If this fails, a dataURI is used.
*/


DownloadManager = (function() {

  DownloadManager.prototype.DOWNLOAD_SCRIPT = 'download.php';

  function DownloadManager(filename, data, mimetype) {
    this.filename = filename;
    this.data = data;
    this.mimetype = mimetype != null ? mimetype : 'application/octet-stream';
    this.downloadDataUriBased = __bind(this.downloadDataUriBased, this);

    this.downloadBlobBased = __bind(this.downloadBlobBased, this);

    this.downloadServerBased = __bind(this.downloadServerBased, this);

    this.testDataUriAvailability = __bind(this.testDataUriAvailability, this);

    this.testBlobAvailability = __bind(this.testBlobAvailability, this);

    this.testServerAvailability = __bind(this.testServerAvailability, this);

    this.download = __bind(this.download, this);

    this.downloadMethodAvailable = {
      serverBased: null,
      blobBased: null,
      dataUriBased: null
    };
  }

  DownloadManager.prototype.download = function() {
    if (this.downloadMethodAvailable.serverBased === null) {
      this.testServerAvailability(this.download);
      return;
    }
    if (this.downloadMethodAvailable.serverBased === true) {
      this.downloadServerBased();
      return;
    }
    if (this.downloadMethodAvailable.blobBased === null) {
      this.testBlobAvailability(this.download);
      return;
    }
    if (this.downloadMethodAvailable.blobBased === true) {
      this.downloadBlobBased();
      return;
    }
    if (this.downloadMethodAvailable.dataUriBased === null) {
      this.testDataUriAvailability(this.download);
      return;
    }
    if (this.downloadMethodAvailable.dataUriBased === true) {
      this.downloadDataUriBased();
    }
  };

  DownloadManager.prototype.testServerAvailability = function(callback) {
    var _this = this;
    if (callback == null) {
      callback = function() {};
    }
    return $.ajax({
      url: this.DOWNLOAD_SCRIPT,
      dataType: 'text',
      success: function(data, status, response) {
        if (response.getResponseHeader('Content-Description') === 'File Transfer') {
          _this.downloadMethodAvailable.serverBased = true;
        } else {
          _this.downloadMethodAvailable.serverBased = false;
        }
        return callback.call(_this);
      },
      error: function(data, status, response) {
        _this.downloadMethodAvailable.serverBased = false;
        return callback.call(_this);
      }
    });
  };

  DownloadManager.prototype.testBlobAvailability = function(callback) {
    if (callback == null) {
      callback = function() {};
    }
    if ((window.webkitURL || window.URL) && (window.Blob || window.MozBlobBuilder || window.WebKitBlobBuilder)) {
      this.downloadMethodAvailable.blobBased = true;
    } else {
      this.downloadMethodAvailable.blobBased = true;
    }
    return callback.call(this);
  };

  DownloadManager.prototype.testDataUriAvailability = function(callback) {
    if (callback == null) {
      callback = function() {};
    }
    this.downloadMethodAvailable.dataUriBased = true;
    return callback.call(this);
  };

  DownloadManager.prototype.downloadServerBased = function() {
    var form, input1, input2, input3;
    input1 = $('<input type="hidden"></input>').attr({
      name: 'filename',
      value: this.filename
    });
    input2 = $('<input type="hidden"></input>').attr({
      name: 'data',
      value: btoa(this.data)
    });
    input3 = $('<input type="hidden"></input>').attr({
      name: 'mimetype',
      value: this.mimetype
    });
    form = $('<form action="' + this.DOWNLOAD_SCRIPT + '" method="post" target="downloads_iframe"></form>');
    form.append(input1).append(input2).append(input3);
    return form.appendTo(document.body).submit().remove();
  };

  DownloadManager.prototype.downloadBlobBased = function(errorCallback) {
    var bb, blob, buf, bufView, downloadLink, i, url, _i, _ref;
    if (errorCallback == null) {
      errorCallback = this.download;
    }
    try {
      buf = new ArrayBuffer(this.data.length);
      bufView = new Uint8Array(buf);
      for (i = _i = 0, _ref = this.data.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        bufView[i] = this.data.charCodeAt(i) & 0xff;
      }
      try {
        blob = new Blob(buf, {
          type: 'application/octet-stream'
        });
      } catch (e) {
        bb = new (window.WebKitBlobBuilder || window.MozBlobBuilder);
        bb.append(buf);
        blob = bb.getBlob('application/octet-stream');
      }
      url = (window.webkitURL || window.URL).createObjectURL(blob);
      downloadLink = $('<a></a>').attr({
        href: url,
        download: this.filename
      });
      $(document.body).append(downloadLink);
      downloadLink[0].click();
      return downloadLink.remove();
    } catch (e) {
      this.downloadMethodAvailable.blobBased = false;
      return errorCallback.call(this);
    }
  };

  DownloadManager.prototype.downloadDataUriBased = function() {
    return document.location.href = "data:application/octet-stream;base64," + btoa(this.data);
  };

  return DownloadManager;

})();

/*
# utilities for client-side reading files
*/


FileHandler = {
  decodeDataURI: function(dataURI) {
    var content, data, meta;
    content = dataURI.indexOf(",");
    meta = dataURI.substr(5, content).toLowerCase();
    data = decodeURIComponent(dataURI.substr(content + 1));
    if (/;\s*base64\s*[;,]/.test(meta)) {
      data = atob(data);
    }
    if (/;\s*charset=[uU][tT][fF]-?8\s*[;,]/.test(meta)) {
      data = decodeURIComponent(escape(data));
    }
    return data;
  },
  handleFiles: function(files) {
    var file, reader;
    file = files[0];
    reader = new FileReader();
    reader.onprogress = FileHandler.handleReaderProgress;
    reader.onloadend = FileHandler.handleReaderLoadEnd;
    return reader.readAsDataURL(file);
  },
  handleReaderProgress: function(evt) {
    var percentLoaded;
    if (evt.lengthComputable) {
      return percentLoaded = evt.loaded / evt.total;
    }
  },
  handleReaderLoadEnd: function(evt) {
    var data, jsonData, parser, xmlDoc;
    if (evt.target.error) {
      throw new Error(evt.target.error + " Error Code: " + evt.target.error.code + " ");
      return;
    }
    data = FileHandler.decodeDataURI(evt.target.result);
    try {
      try {
        jsonData = JSON.parse(data);
        return window.courseManager.loadGraph(data);
      } catch (e) {
        parser = new DOMParser;
        xmlDoc = parser.parseFromString(data, 'text/xml');
        data = decodeURIComponent(xmlDoc.querySelector('coursemapper').textContent);
        jsonData = JSON.parse(data);
        return window.courseManager.loadGraph(data);
      }
    } catch (e) {
      console.log(e);
      throw new Error("Not valid JSON or SVG (containing <coursemapper>JSON</coursemapper>) data");
    }
  },
  dragEnter: function(evt) {
    $('#dropcontainer').show();
    $('.tabs').hide();
    $('#forkme').hide();
    evt.stopPropagation();
    return evt.preventDefault();
  },
  dragExit: function(evt) {
    $('#dropcontainer').hide();
    $('#dropbox').removeClass('dropbox-hover');
    $('.tabs').show();
    $('#forkme').show();
    if (evt != null) {
      evt.stopPropagation();
      return evt.preventDefault();
    }
  },
  dragOver: function(evt, b) {
    if (!(evt != null)) {
      $('#dropbox').removeClass('dropbox-hover');
      return;
    }
    $('#dropbox').addClass('dropbox-hover');
    evt.stopPropagation();
    return evt.preventDefault();
  },
  drop: function(evt) {
    var count, files;
    evt.stopPropagation();
    evt.preventDefault();
    files = evt.dataTransfer.files;
    count = files.length;
    if (count > 0) {
      FileHandler.handleFiles(files);
    }
    return FileHandler.dragExit();
  }
};
