// Generated by CoffeeScript 1.3.3
var Course, CourseManager, CourseShell, CourseUtils, DiGraph, courseDataLoaded, hideCoursesFromDep, objToString, populateYearTable, showCoursesFromDep, titleCaps,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

objToString = function(obj) {
  var p, ret, v;
  ret = '{ ';
  for (p in obj) {
    v = obj[p];
    ret += " " + p + ":" + v + ", ";
  }
  return ret + "}";
};

/*
# * Title Caps
# *
# * Ported to JavaScript By John Resig - http://ejohn.org/ - 21 May 2008
# * Original by John Gruber - http://daringfireball.net/ - 10 May 2008
# * License: http://www.opensource.org/licenses/mit-license.php
*/


titleCaps = (function() {
  var lower, punct, small, upper;
  lower = function(word) {
    return word.toLowerCase();
  };
  upper = function(word) {
    return word.substr(0, 1).toUpperCase() + word.substr(1);
  };
  small = "(a|an|and|as|at|but|by|en|for|if|in|of|on|or|the|to|v[.]?|via|vs[.]?|with)";
  punct = "([!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]*)";
  titleCaps = function(title) {
    var index, m, parts, split;
    parts = [];
    split = /[:.;?!] |(?: |^)["�]/g;
    index = 0;
    while (true) {
      m = split.exec(title);
      parts.push(title.substring(index, (m ? m.index : title.length)).replace(/\b([A-Za-z][a-z.'�]*)\b/g, function(all) {
        if (/[A-Za-z]\.[A-Za-z]/.test(all)) {
          return all;
        } else {
          return upper(all);
        }
      }).replace(/\b(i|v|x|l|c|d|m)+\b/i, function(all) {
        return all.toUpperCase();
      }).replace(RegExp("\\b" + small + "\\b", "ig"), lower).replace(RegExp("^" + punct + small + "\\b", "ig"), function(all, punct, word) {
        return punct + upper(word);
      }).replace(RegExp("\\b" + small + punct + "$", "ig"), upper));
      index = split.lastIndex;
      if (m) {
        parts.push(m[0]);
      } else {
        break;
      }
    }
    return parts.join("").replace(RegExp(" V(s?)\\. ", "g"), " v$1. ").replace(/(['�])S\b/g, "$1s").replace(/\b(AT&T|Q&A)\b/g, function(all) {
      return all.toUpperCase();
    });
  };
  return titleCaps;
})();

$(document).ready(function() {
  /*
      $.ajax
          url: 'MATH_items.json'
          dataType: 'json'
          success: courseDataLoaded
  */
  $('.course-status').buttonset().disableSelection();
  $('button').button();
  showCoursesFromDep('MATH');
  $('#show-courses').click(function() {
    var dep;
    dep = $('#department-list option:selected()').val();
    return showCoursesFromDep(dep);
  });
  return $('#hide-courses').click(function() {
    var dep;
    dep = $('#department-list option:selected()').val();
    return hideCoursesFromDep(dep);
  });
});

window.courses = {};

showCoursesFromDep = function(dep) {
  var buttonsToBeCreated, course, courseDataNeedsLoading, hash, _ref;
  buttonsToBeCreated = {};
  courseDataNeedsLoading = true;
  _ref = window.courses;
  for (hash in _ref) {
    course = _ref[hash];
    if (course.subject === dep) {
      courseDataNeedsLoading = false;
      if (course.elm) {
        course.$elm.show();
      } else {
        buttonsToBeCreated[hash] = course;
      }
    }
  }
  populateYearTable(buttonsToBeCreated);
  if (courseDataNeedsLoading) {
    return $.ajax({
      url: "course_data/" + dep + ".json",
      dataType: 'json',
      success: courseDataLoaded
    });
  }
};

hideCoursesFromDep = function(dep) {
  var course, hash, _ref, _results;
  _ref = window.courses;
  _results = [];
  for (hash in _ref) {
    course = _ref[hash];
    if (course.subject === dep && course.state.required === false && course.state.elective === false) {
      if (course.elm) {
        _results.push(course.$elm.hide());
      } else {
        _results.push(void 0);
      }
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

courseDataLoaded = function(data, textState, jsXHR) {
  var c, course, elm, _i, _j, _len, _len1, _ref, _results;
  for (_i = 0, _len = data.length; _i < _len; _i++) {
    c = data[_i];
    course = new Course(c);
    window.courses[course.hash] = course;
  }
  populateYearTable(window.courses);
  $('.courses').sortable({
    connectWith: '.courses',
    distance: 25,
    deactivate: function(event, ui) {
      return ui.item.addClass('noclick');
    }
  }).disableSelection();
  _ref = $('.course');
  _results = [];
  for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
    elm = _ref[_j];
    if (!elm.course.bound) {
      elm.course.bound = true;
      _results.push($(elm).click(function(evt) {
        var hash, _ref1;
        _ref1 = window.courses;
        for (hash in _ref1) {
          course = _ref1[hash];
          course.setState({
            selected: false
          });
        }
        evt.currentTarget.course.setState({
          selected: true
        });
        if ($(evt.currentTarget).hasClass('noclick')) {
          $(evt.currentTarget).removeClass('noclick');
          return;
        }
        evt.currentTarget.course.toggleState();
        CourseUtils.updatePrereqTags();
        evt.currentTarget.course.showCourseInfo($('.course-info')[0]);
        return $("#dot").val(CourseUtils.createDotGraph());
      }));
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

populateYearTable = function(courses) {
  var c, container, course, hash, k, list, year, years, _results;
  years = {};
  for (k in courses) {
    c = courses[k];
    year = c.number.charAt(0);
    if (!(years[year] != null)) {
      years[year] = [];
    }
    years[year].push([c.hash, c]);
  }
  _results = [];
  for (year in years) {
    list = years[year];
    if (year === '1' || year === '2' || year === '3' || year === '4') {
      list.sort();
      container = $(".year" + year + " .courses");
      _results.push((function() {
        var _i, _len, _ref, _results1;
        _results1 = [];
        for (_i = 0, _len = list.length; _i < _len; _i++) {
          _ref = list[_i], hash = _ref[0], course = _ref[1];
          _results1.push(container.append(course.getButton()));
        }
        return _results1;
      })());
    } else {
      _results.push(void 0);
    }
  }
  return _results;
};

/*
# Class to manage and keep the sync of all course on the webpage
# and their state.
*/


CourseManager = (function() {

  function CourseManager() {
    this.courses = {};
  }

  CourseManager.prototype.updateCourseState = function(course, state) {
    var c, _i, _len, _ref, _results;
    _ref = this.courses[course] || [];
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      _results.push(c.setState(state));
    }
    return _results;
  };

  CourseManager.prototype.addCourse = function(course) {
    var hash;
    hash = '' + course;
    if (!this.courses[hash]) {
      this.courses[hash] = [];
    }
    this.courses[hash].push(course);
    return course;
  };

  CourseManager.prototype.removeCourse = function(course) {
    var hash, index;
    hash = '' + course;
    if (!this.courses[hash]) {
      return false;
    }
    index = this.courses[hash].indexOf(course);
    if (index >= 0) {
      return this.courses[hash].splice(index, 1);
    }
  };

  CourseManager.prototype.removeAllCourseInstances = function(course) {
    return delete this.courses[course];
  };

  return CourseManager;

})();

/*
# Utility functions for dealing with lists of courses and their prereqs
*/


CourseUtils = {
  computePrereqTree: function(courses, selected) {
    var course, hash, pruned, ret, _i, _len, _ref;
    if (selected == null) {
      selected = [];
    }
    if (!(courses != null)) {
      throw new Error("computePrereqTree requires a list of course hash's");
    }
    ret = {
      op: 'and',
      data: []
    };
    for (_i = 0, _len = courses.length; _i < _len; _i++) {
      hash = courses[_i];
      course = window.courses[hash];
      if (course.prereqs != null) {
        pruned = Course.prunePrereqs(course.prereqs, selected);
        pruned = Course.simplifyPrereqs(pruned);
        if (((_ref = pruned.data) != null ? _ref.length : void 0) > 0) {
          pruned.requiredBy = course;
          ret.data.push(pruned);
        }
      }
    }
    return ret;
  },
  getSelectedCourses: function() {
    var c, hash;
    return (function() {
      var _ref, _results;
      _ref = window.courses;
      _results = [];
      for (hash in _ref) {
        c = _ref[hash];
        if (c.state.required || c.state.elective) {
          _results.push(hash);
        }
      }
      return _results;
    })();
  },
  updatePrereqTags: function() {
    var c, hash, k, prereqs, selected, unmet, _i, _len, _ref, _ref1;
    selected = CourseUtils.getSelectedCourses();
    prereqs = CourseUtils.computePrereqTree(selected, selected);
    unmet = {};
    _ref = Course.flattenPrereqs(prereqs);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      unmet[Course.hashCourse(c)] = true;
    }
    _ref1 = window.courses;
    for (hash in _ref1) {
      c = _ref1[hash];
      c.setState({
        prereq: !!unmet[hash]
      });
    }
    console.log(((function() {
      var _results;
      _results = [];
      for (k in unmet) {
        _results.push(k);
      }
      return _results;
    })()).join(' '));
    return unmet;
  },
  createDotGraph: function() {
    var allCourses, allCoursesHash, c, course, courseHashLookup, e, edges, elms, g, hash, i, p, prereqs, ret, t, titles, years, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref;
    years = {
      1: [],
      2: [],
      3: [],
      4: []
    };
    _ref = [1, 2, 3, 4];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      elms = $(".year" + i + " .courses").children();
      for (_j = 0, _len1 = elms.length; _j < _len1; _j++) {
        e = elms[_j];
        if (e.course.state.required || e.course.state.elective) {
          years[i].push(e.course);
        }
      }
    }
    allCourses = years[1].concat(years[2]).concat(years[3]).concat(years[4]);
    allCoursesHash = (function() {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = allCourses.length; _k < _len2; _k++) {
        c = allCourses[_k];
        _results.push(c.hash);
      }
      return _results;
    })();
    courseHashLookup = {};
    for (_k = 0, _len2 = allCoursesHash.length; _k < _len2; _k++) {
      hash = allCoursesHash[_k];
      courseHashLookup[hash] = true;
    }
    edges = [];
    for (_l = 0, _len3 = allCourses.length; _l < _len3; _l++) {
      course = allCourses[_l];
      if (course.prereqs != null) {
        prereqs = (function() {
          var _len4, _m, _ref1, _results;
          _ref1 = Course.flattenPrereqs(course.prereqs);
          _results = [];
          for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
            c = _ref1[_m];
            _results.push(Course.hashCourse(c));
          }
          return _results;
        })();
        for (_m = 0, _len4 = prereqs.length; _m < _len4; _m++) {
          p = prereqs[_m];
          if (courseHashLookup[p]) {
            edges.push([p, course.hash]);
          }
        }
      }
    }
    g = new DiGraph(edges, allCourses);
    g.years = years;
    ret = g.toDot('unpruned') + "\n";
    console.log(g.eliminateRedundantEdges());
    titles = {};
    for (t in g.nodes) {
      titles[t] = titleCaps((window.courses[t].data.title + "").toLowerCase());
    }
    return g.toDot('pruned', titles);
  }
};

/*
# Object to store course info along with managing a button
# relating to a particular course and all of its state,
# prereqs, etc.
*/


Course = (function() {

  Course.hashCourse = function(course) {
    return "" + course.subject + " " + course.number;
  };

  function Course(data) {
    var _ref;
    this.data = data;
    this.hash = Course.hashCourse(this.data);
    _ref = this.data, this.subject = _ref.subject, this.number = _ref.number, this.prereqs = _ref.prereqs;
    this.elm = null;
    this.state = {
      required: false,
      elective: false,
      selected: false,
      prereq: false
    };
  }

  Course.prototype.toString = function() {
    return this.hash;
  };

  Course.prototype.setStateCallbacks = [];

  Course.prototype.getButton = function() {
    if (this.elm) {
      return this.elm;
    }
    this.$elm = $("<div class='course'><div class='annotation'></div><div class='number'>" + this.subject + " " + this.number + "</div></div>");
    this.elm = this.$elm[0];
    this.elm.course = this;
    this.setState(this.state);
    return this.elm;
  };

  Course.prototype.setState = function(state, forceUpdate) {
    var f, k, s, stateChanged, _i, _len, _ref, _ref1, _ref2;
    if (state == null) {
      state = {};
    }
    if (forceUpdate == null) {
      forceUpdate = false;
    }
    stateChanged = forceUpdate;
    for (k in state) {
      s = state[k];
      if (this.state[k] !== s || forceUpdate) {
        stateChanged = true;
        this.state[k] = s;
        if (s) {
          if ((_ref = this.$elm) != null) {
            _ref.addClass(k);
          }
        } else {
          if ((_ref1 = this.$elm) != null) {
            _ref1.removeClass(k);
          }
        }
      }
    }
    if (stateChanged) {
      _ref2 = this.setStateCallbacks;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        f = _ref2[_i];
        f();
      }
    }
  };

  Course.prototype.toggleState = function() {
    var state;
    state = {
      required: false,
      elective: false
    };
    if (this.state.required) {
      state.elective = true;
    }
    if (this.state.elective) {
      state.elective = false;
    }
    if (!(this.state.required || this.state.elective)) {
      state.required = true;
    }
    this.setState(state);
  };

  Course.prototype.showCourseInfo = function(infoarea) {
    var $infoarea;
    $infoarea = $(infoarea);
    $infoarea.find('.course-name').html("" + this.hash + " &mdash; " + this.data.title);
    $infoarea.find('.prereq-area').html(Course.prereqsToDivs(this.prereqs));
    this.unbindRadioButtons(infoarea);
    this.bindRadioButtons(infoarea);
    return this.setState({}, true);
  };

  Course.prototype.bindRadioButtons = function(infoarea) {
    var changeState, changeToggle,
      _this = this;
    changeState = function(evt) {
      var val;
      val = $(evt.currentTarget).parent().find('input:checked').val();
      if (!(val != null) || val === 'none') {
        _this.setState({
          required: false,
          elective: false
        });
      }
      if (val === 'required') {
        _this.setState({
          required: true,
          elective: false
        });
      }
      if (val === 'elective') {
        return _this.setState({
          required: false,
          elective: true
        });
      }
    };
    infoarea.boundRadioFunction = changeState;
    $(infoarea).find('input').bind('change', changeState);
    changeToggle = function() {
      $(infoarea).find('input').attr('checked', false);
      if (_this.state.required) {
        $(infoarea).find('input[value=required]').attr('checked', true);
      } else if (_this.state.elective) {
        $(infoarea).find('input[value=elective]').attr('checked', true);
      } else {
        $(infoarea).find('input[value=none]').attr('checked', true);
      }
      try {
        return $('.course-status').buttonset('refresh');
      } catch (e) {

      }
    };
    this.setStateCallbacks.push(changeToggle);
    return infoarea.boundChangeToggle = [this, changeToggle];
  };

  Course.prototype.unbindRadioButtons = function(infoarea) {
    var elm, func, index;
    $(infoarea).find('input').unbind('change', infoarea.boundRadioFunction);
    if (infoarea.boundChangeToggle) {
      elm = infoarea.boundChangeToggle[0];
      func = infoarea.boundChangeToggle[1];
      index = elm.setStateCallbacks.indexOf(func);
      if (index >= 0) {
        return elm.setStateCallbacks.splice(index, 1);
      }
    }
  };

  Course.prereqsToString = function(prereq) {
    var p;
    if (!(prereq != null)) {
      return "";
    }
    if (prereq.subject) {
      return Course.hashCourse(prereq);
    }
    if (prereq.op) {
      if (typeof prereq.op === 'string') {
        return "(" + ((function() {
          var _i, _len, _ref, _results;
          _ref = prereq.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            _results.push(Course.prereqsToString(p));
          }
          return _results;
        })()).join(" " + prereq.op + " ") + ")";
      } else {
        return "";
      }
    }
  };

  Course.prereqsToDivs = function(prereq) {
    var course, courseElm, divs, elm, number, prereqsToDivs, subject, _i, _len, _ref;
    prereqsToDivs = function(prereq) {
      var hash, p;
      if (!(prereq != null)) {
        return "";
      }
      if (prereq.subject) {
        hash = Course.hashCourse(prereq);
        return "<course id='" + hash + "' subject='" + prereq.subject + "' number='" + prereq.number + "'>" + hash + "</course>";
      }
      if (prereq.op) {
        if (typeof prereq.op === 'string') {
          return ("<ul class='prereq-tree prereq-" + prereq.op + "'><li class='prereq-tree prereq-" + prereq.op + "'>") + ((function() {
            var _i, _len, _ref, _results;
            _ref = prereq.data;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              p = _ref[_i];
              _results.push(prereqsToDivs(p));
            }
            return _results;
          })()).join("</li><li class='prereq-tree prereq-" + prereq.op + "'>") + "</ul>";
        } else {
          return "";
        }
      }
    };
    divs = $(prereqsToDivs(prereq));
    _ref = divs.find('course');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      subject = elm.getAttribute('subject');
      number = elm.getAttribute('number');
      course = new CourseShell({
        subject: subject,
        number: number
      });
      courseElm = course.getButton();
      elm.parentNode.replaceChild(courseElm, elm);
    }
    return divs;
  };

  Course.prunePrereqs = function(prereq, courses) {
    var course, prunedBranch, ret, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (!(prereq != null)) {
      throw new Error("Yikes.  We errored while pruning the prereqs!");
    }
    ret = {
      op: 'and',
      data: []
    };
    if (prereq.subject) {
      if (courses.indexOf(Course.hashCourse(prereq)) === -1) {
        ret.data.push(prereq);
      }
    }
    switch (prereq.op) {
      case 'or':
        ret.op = 'or';
        _ref = prereq.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          course = _ref[_i];
          prunedBranch = Course.prunePrereqs(course, courses);
          if (((_ref1 = prunedBranch.data) != null ? _ref1.length : void 0) === 0) {
            return {
              op: 'and',
              data: []
            };
          }
          ret.data.push(prunedBranch);
        }
        break;
      case 'and':
        _ref2 = prereq.data;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          course = _ref2[_j];
          prunedBranch = Course.prunePrereqs(course, courses);
          if (((_ref3 = prunedBranch.data) != null ? _ref3.length : void 0) !== 0) {
            ret.data.push(prunedBranch);
          }
        }
    }
    return ret;
  };

  Course.simplifyPrereqs = function(prereq) {
    var removeParen;
    removeParen = function(prereq) {
      var p;
      if (!(prereq.data != null)) {
        return prereq;
      }
      if (prereq.data.length === 1) {
        return removeParen(prereq.data[0]);
      }
      return {
        op: prereq.op,
        data: (function() {
          var _i, _len, _ref, _results;
          _ref = prereq.data;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            p = _ref[_i];
            _results.push(removeParen(p));
          }
          return _results;
        })()
      };
    };
    return removeParen(prereq);
  };

  Course.flattenPrereqs = function(prereq) {
    var c, ret, _i, _len, _ref;
    if (prereq != null ? prereq.subject : void 0) {
      return [prereq];
    }
    if (prereq != null ? prereq.op : void 0) {
      ret = [];
      _ref = prereq.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        ret = ret.concat(Course.flattenPrereqs(c));
      }
      return ret;
    }
    return [];
    throw new Error('Error flattening prereqs');
  };

  return Course;

})();

/*
# CourseShell looks like a Course button, but it is empty inside.
# Instead, by setting just the subject and number, CourseShell can
# be used to add a button that will dynamically load a courses information
# when clicked
*/


CourseShell = (function(_super) {

  __extends(CourseShell, _super);

  function CourseShell() {
    return CourseShell.__super__.constructor.apply(this, arguments);
  }

  return CourseShell;

})(Course);

/*
# Class to perform operations on a directed graph like
# searching for multiple paths, finding neighbors, etc.
*/


DiGraph = (function() {

  function DiGraph(edges, nodes) {
    var e, n, _i, _j, _len, _len1;
    if (nodes == null) {
      nodes = [];
    }
    this.nodes = {};
    this.edges = [];
    this.forwardNeighborHash = null;
    this.backwardNeighborHash = null;
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      n = nodes[_i];
      this.nodes[n] = true;
    }
    for (_j = 0, _len1 = edges.length; _j < _len1; _j++) {
      e = edges[_j];
      this.edges.push(e.slice());
      this.nodes[e[0]] = true;
      this.nodes[e[1]] = true;
    }
  }

  DiGraph.prototype._generateForwardNeighborHash = function() {
    var e, hash, _i, _len, _ref;
    if (this.forwardNeighborHash) {
      return;
    }
    hash = {};
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (!(hash[e[0]] != null)) {
        hash[e[0]] = [];
      }
      hash[e[0]].push(e[1]);
    }
    return this.forwardNeighborHash = hash;
  };

  DiGraph.prototype._generateBackwardNeighborHash = function() {
    var e, hash, _i, _len, _ref;
    if (this.backwardNeighborHash) {
      return;
    }
    hash = {};
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      if (!(hash[e[1]] != null)) {
        hash[e[1]] = [];
      }
      hash[e[1]].push(e[0]);
    }
    return this.backwardNeighborHash = hash;
  };

  DiGraph.prototype.edgeSpan = function(node) {
    var findNeighbors, maxDepth, ret,
      _this = this;
    ret = {};
    this._generateForwardNeighborHash();
    maxDepth = Object.keys(this.nodes).length;
    findNeighbors = function(node, depth) {
      var l, _i, _len, _ref;
      ret = [];
      if (depth >= maxDepth || !(node != null) || !(_this.forwardNeighborHash[node] != null)) {
        return ret;
      }
      _ref = _this.forwardNeighborHash[node];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        ret = ret.concat(findNeighbors(l, depth + 1));
      }
      return ret.concat(_this.forwardNeighborHash[node]);
    };
    return findNeighbors(node, 0);
  };

  DiGraph.prototype.isPath = function(n1, n2) {
    return this.edgeSpan(n1).indexOf(n2) !== -1 || this.edgeSpan(n2).indexOf(n1) !== -1;
  };

  DiGraph.prototype.eliminateRedundantEdgesToNode = function(node) {
    var ancestors, n, s, span, spanHash, _i, _j, _k, _len, _len1, _len2;
    this._generateBackwardNeighborHash();
    this._generateForwardNeighborHash();
    ancestors = this.backwardNeighborHash[node] || [];
    for (_i = 0, _len = ancestors.length; _i < _len; _i++) {
      n = ancestors[_i];
      span = this.edgeSpan(n);
      spanHash = {};
      for (_j = 0, _len1 = span.length; _j < _len1; _j++) {
        s = span[_j];
        spanHash[s] = true;
      }
      for (_k = 0, _len2 = ancestors.length; _k < _len2; _k++) {
        s = ancestors[_k];
        if (s === n) {
          continue;
        }
        if (spanHash[s]) {
          this.removeEdge([n, node]);
          return 1 + this.eliminateRedundantEdgesToNode(node);
        }
      }
    }
    return 0;
  };

  DiGraph.prototype.eliminateRedundantEdges = function() {
    var n, ret;
    ret = 0;
    for (n in this.nodes) {
      ret += this.eliminateRedundantEdgesToNode(n);
    }
    return ret;
  };

  DiGraph.prototype.removeEdge = function(edge) {
    var e, i, indices, _i, _j, _len, _len1, _ref;
    indices = [];
    _ref = this.edges;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      e = _ref[i];
      if (DiGraph.edgesEqual(e, edge)) {
        indices.unshift(i);
      }
    }
    for (_j = 0, _len1 = indices.length; _j < _len1; _j++) {
      i = indices[_j];
      this.edges.splice(i, 1);
    }
    this.forwardNeighborHash = null;
    return this.backwardNeighborHash = null;
  };

  DiGraph.edgesEqual = function(e1, e2) {
    return (e1[0] === e2[0]) && (e1[1] === e2[1]);
  };

  DiGraph.prototype.findForwardNeighborsOfSubgraph = function(subgraphNodes) {
    var child, n, nodes, ret, _i, _j, _len, _len1, _ref;
    if (subgraphNodes instanceof Array) {
      nodes = subgraphNodes;
      subgraphNodes = {};
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        subgraphNodes[n] = true;
      }
    }
    this._generateForwardNeighborHash();
    ret = {};
    for (n in subgraphNodes) {
      _ref = this.forwardNeighborHash[n] || [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        child = _ref[_j];
        if (!subgraphNodes[child]) {
          ret[child] = true;
        }
      }
    }
    return ret;
  };

  DiGraph.prototype.findBackwardNeighborsOfSubgraph = function(subgraphNodes) {
    var child, n, nodes, ret, _i, _j, _len, _len1, _ref;
    if (subgraphNodes instanceof Array) {
      nodes = subgraphNodes;
      subgraphNodes = {};
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        subgraphNodes[n] = true;
      }
    }
    this._generateBackwardNeighborHash();
    ret = {};
    for (n in subgraphNodes) {
      _ref = this.backwardNeighborHash[n] || [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        child = _ref[_j];
        if (!subgraphNodes[child]) {
          ret[child] = true;
        }
      }
    }
    return ret;
  };

  DiGraph.prototype.findSources = function() {
    var n, ret;
    ret = [];
    this._generateBackwardNeighborHash;
    for (n in this.nodes) {
      if (!this.backwardNeighborHash[n]) {
        ret.push(n);
      }
    }
    return ret;
  };

  DiGraph.prototype.toDot = function(name, titles) {
    var c, e, i, ret, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (titles == null) {
      titles = {};
    }
    ret = "digraph " + name + " {\n";
    ret += "\tnode [shape=box,style=rounded]\n";
    _ref = this.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      ret += "\t\"" + e[0] + "\" -> \"" + e[1] + "\"\n";
    }
    ret += "\n";
    _ref1 = [1, 2, 3, 4];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      i = _ref1[_j];
      if (this.years) {
        ret += "\tsubgraph year" + i + " {\n";
        ret += "\t\trank=same\n";
        ret += "\t\tlabel=\"Year " + i + "\"\n";
        _ref2 = this.years[i];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          c = _ref2[_k];
          ret += "\t\t\t\"" + c.hash + "\" [label=<<font color=\"red\">" + c.hash + "</font><br/><font color=\"blue\">" + titles[c] + "</font>>]\n";
        }
        ret += "\n\t}\n";
      }
    }
    ret += "}";
    return ret;
  };

  /*
      # Functions for doing rankings and orderings of graphs
      # to implement the dot graph layout algorithm
  */


  DiGraph.prototype.generateFeasibleRank = function(graph) {
    var child, d, i, k, max_rank, min_rank, n, parent, rankFracHash, rankFracs, ranks, v, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    if (graph == null) {
      graph = this;
    }
    graph._generateForwardNeighborHash();
    graph._generateBackwardNeighborHash();
    ranks = {};
    for (n in this.nodes) {
      min_rank = 0;
      max_rank = 1;
      _ref = graph.backwardNeighborHash[n] || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        parent = _ref[_i];
        if (ranks[parent]) {
          min_rank = Math.max(ranks[parent], min_rank);
        }
      }
      _ref1 = graph.forwardNeighborHash[n] || [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        child = _ref1[_j];
        if (ranks[child]) {
          max_rank = Math.min(ranks[child], max_rank);
        }
      }
      ranks[n] = (min_rank + max_rank) / 2;
    }
    rankFracs = (function() {
      var _results;
      _results = [];
      for (k in ranks) {
        v = ranks[k];
        _results.push(v);
      }
      return _results;
    })();
    rankFracs.sort();
    rankFracHash = {};
    for (i = _k = 0, _len2 = rankFracs.length; _k < _len2; i = ++_k) {
      d = rankFracs[i];
      rankFracHash[d] = i;
    }
    for (k in ranks) {
      v = ranks[k];
      ranks[k] = rankFracHash[v];
    }
    return ranks;
  };

  DiGraph.prototype.findMaximalTightTree = function(ranks, rootNode, graph) {
    var DEFAULT_DELTA, expandTightTree, maximalTree, minRankDelta, sources;
    if (graph == null) {
      graph = this;
    }
    DEFAULT_DELTA = 1;
    minRankDelta = graph.minRankDelta || {};
    expandTightTree = function(tailNode, headNode, treeNodes, edges) {
      var c, edgeDelta, _i, _len, _ref;
      if (treeNodes == null) {
        treeNodes = {};
      }
      if (edges == null) {
        edges = [];
      }
      if (treeNodes[headNode]) {
        return treeNodes;
      }
      edgeDelta = minRankDelta[[tailNode, headNode]] || DEFAULT_DELTA;
      if (ranks[headNode] - ranks[tailNode] === edgeDelta || headNode === tailNode) {
        treeNodes[headNode] = true;
        if (tailNode !== headNode) {
          edges.push([tailNode, headNode]);
        }
        _ref = graph.forwardNeighborHash[headNode] || [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          expandTightTree(headNode, c, treeNodes, edges);
        }
      }
      return {
        nodes: treeNodes,
        edges: edges
      };
    };
    if (!rootNode) {
      sources = graph.findSources();
      if (sources.length === 0) {
        throw new Error("Tried to find a Maximal and Tight tree on a graph with no sources!");
      }
    } else {
      sources = [rootNode];
    }
    maximalTree = expandTightTree(sources[0], sources[0]);
    return maximalTree;
  };

  /*
      # returns the minimum difference in ranks between
      # node and its ancestors.
      getRankDiff: (ranks, node, graph=this) ->
          graph._generateBackwardNeighborHash()
          ancestors = graph.backwardNeighborHash[node] || []
          diff = Infinity
          for n in ancestors
              diff = Math.min(diff, ranks[node] - ranks[n])
          return diff
  
      # returns the minimum difference in ranks among node
      # and its ancestors minus the minimum allowed rank delta
      getSlack: (ranks, node, graph=this) ->
          DEFAULT_DELTA = 1
          minRankDelta = graph.minRankDelta || {}
  
          graph._generateBackwardNeighborHash()
          ancestors = graph.backwardNeighborHash[node] || []
          diff = Infinity
          tail = null
          for n in ancestors
              rankDiff = ranks[node] - ranks[n] - (minRankDelta[[n,node]] || 0)
              if rankDiff < diff
                  diff = rankDiff
                  tail = n
          return {slack: diff, edge: [tail, node]}
  */


  DiGraph.prototype.getIncidentEdgeOfMinimumSlack = function(ranks, tree, graph) {
    var DEFAULT_DELTA, e, giveSlack, incidentEdges, minRankDelta, slacks;
    if (graph == null) {
      graph = this;
    }
    DEFAULT_DELTA = 1;
    minRankDelta = graph.minRankDelta || {};
    incidentEdges = (function() {
      var _i, _len, _ref, _results;
      _ref = graph.edges;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        if (tree[e[0]] ^ tree[e[1]]) {
          _results.push(e);
        }
      }
      return _results;
    })();
    giveSlack = function(edge) {
      var rankDiff;
      rankDiff = Math.abs(ranks[edge[0]] - ranks[edge[1]]);
      return rankDiff - (minRankDelta[edge] || 0);
    };
    slacks = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = incidentEdges.length; _i < _len; _i++) {
        e = incidentEdges[_i];
        _results.push([giveSlack(e), e]);
      }
      return _results;
    })();
    slacks.sort();
    return slacks[0];
  };

  DiGraph.prototype.findFeasibleSpanningTree = function(graph) {
    var edge, numNodes, ranks, slack, tree, _ref, _results;
    if (graph == null) {
      graph = this;
    }
    ranks = graph.generateFeasibleRank();
    tree = graph.findMaximalTightTree(ranks);
    numNodes = Object.keys(graph.nodes).length;
    _results = [];
    while (Object.keys(tree.treeNodes).length < numNodes) {
      _results.push((_ref = graph.getIncidentEdgeOfMinimumSlack(ranks, tree.treeNodes), slack = _ref[0], edge = _ref[1], _ref));
    }
    return _results;
  };

  return DiGraph;

})();
