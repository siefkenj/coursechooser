// Generated by CoffeeScript 1.6.3
/*
# Objects for dealing with the Graphviz dot/xdot format.
# After obtaining an ast using DotParser.parser(source),
# you may find the following useful:
#
# astToStr: Turn an ast back into a string
#
# new DotGraph(ast): Get a dotgraph object.  Calling .walk on this
#   object will walk the ast and populate the .notes, .edges, and .graphs
#   properties.
#
# new XDotGraph(ast): Subclass of DotGraph.  Calling .walk will populate
#   .nodes, .edges, and .graphs and will parse any of the known attributes
#   to javascript objects and convert their values to pixels if necessary.
*/

var DotGraph, XDotGraph, astToStr, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

astToStr = function(ast, indentLevel, indentChar) {
  var attrListToStr, attrs, escape, indentStr, n, ret, _ref;
  if (indentLevel == null) {
    indentLevel = 0;
  }
  if (indentChar == null) {
    indentChar = '\t';
  }
  /* enclose a string in quotes if it contains any non-letters or if it is a keyword
  if the value == null, return double quotes
  */

  escape = function(s) {
    if (s == null) {
      return "\"\"";
    }
    if (/^[a-zA-Z0-9]+$/.test(s) && !/^(graph|digraph|subgraph|node|edge|strict)$/.test(s)) {
      return s;
    } else {
      return "\"" + (('' + s).replace(/"/g, '\\"')) + "\"";
    }
  };
  attrListToStr = function(l) {
    var attrStrings, e, s, _i, _len, _ref;
    if (!l || l.length === 0) {
      return "";
    }
    attrStrings = [];
    for (_i = 0, _len = l.length; _i < _len; _i++) {
      e = l[_i];
      s = e.id + "=";
      if ((_ref = e.eq) != null ? _ref.html : void 0) {
        s += "<" + e.eq.value + ">";
      } else {
        s += escape(e.eq);
      }
      attrStrings.push(s);
    }
    return "[" + (attrStrings.join(", ")) + "]";
  };
  ret = '';
  indentStr = new Array(indentLevel + 1).join(indentChar);
  if (ast instanceof Array) {
    ret = ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        n = ast[_i];
        _results.push(astToStr(n, indentLevel));
      }
      return _results;
    })()).join('\n');
  }
  switch (ast.type) {
    case 'digraph':
    case 'graph':
    case 'subgraph':
      if (ast.strict) {
        ret += indentStr + " strict " + ast.type;
      } else {
        ret += indentStr + ast.type;
      }
      if (ast.id) {
        ret += " " + ast.id;
      }
      ret += " {";
      if (ast.children.length === 0) {
        ret += " }\n";
      } else {
        ret += "\n";
        ret += astToStr(ast.children, indentLevel + 1);
        ret += "\n" + indentStr + "}";
      }
      break;
    case 'attr_stmt':
      ret += indentStr + ast.target;
      attrs = attrListToStr(ast.attr_list);
      if (attrs) {
        ret += " " + attrs;
      }
      break;
    case 'node_stmt':
      ret += indentStr + escape(ast.node_id.id);
      if (ast.node_id.port) {
        ret += ":" + (escape(ast.node_id.port.id));
      }
      if ((_ref = ast.node_id.port) != null ? _ref.compass_pt : void 0) {
        ret += ":" + ast.node_id.port.compass_pt;
      }
      attrs = attrListToStr(ast.attr_list);
      if (attrs) {
        ret += " " + attrs;
      }
      break;
    case 'edge_stmt':
      ret += indentStr + ((function() {
        var _i, _len, _ref1, _results;
        _ref1 = ast.edge_list;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          n = _ref1[_i];
          _results.push(astToStr(n, 0));
        }
        return _results;
      })()).join(' -> ');
      attrs = attrListToStr(ast.attr_list);
      if (attrs) {
        ret += " " + attrs;
      }
      break;
    case 'node_id':
      ret += indentStr + escape(ast.id);
  }
  return ret;
};

/*
# Takes in an AST of the dot/xdot file format
# and produces a graph object where nodes/edges/subgraphs
# may be queried for attributes
*/


DotGraph = (function() {
  /*
  # returns an 8 digit random string that can be used
  # to give anonymous graphs unique ids.
  */

  var DotSubgraph, attrListToObj, copy, doubleCopy, giveRandomKey, mergeLeftNoOverried, mergeLeftOverried;

  giveRandomKey = function() {
    return Math.random().toFixed(8).slice(2);
  };

  /* adds any attributes of obj2 that are missing from obj1 to obj1*/


  mergeLeftNoOverried = function(obj1, obj2) {
    var k, v;
    for (k in obj2) {
      v = obj2[k];
      if (obj1[k] == null) {
        obj1[k] = v;
      }
    }
    return obj1;
  };

  /* adds every attribute from obj2 to obj1 overriding ones that already exist in obj1*/


  mergeLeftOverried = function(obj1, obj2) {
    var k, v;
    for (k in obj2) {
      v = obj2[k];
      obj1[k] = v;
    }
    return obj1;
  };

  /* shallow copy an object*/


  copy = function(obj) {
    var k, ret, v;
    ret = {};
    for (k in obj) {
      v = obj[k];
      ret[k] = v;
    }
    return ret;
  };

  /* copy an object two levels deep*/


  doubleCopy = function(obj) {
    var k, ret, v;
    ret = {};
    for (k in obj) {
      v = obj[k];
      ret[k] = copy(v);
    }
    return ret;
  };

  /* takes an attr_list from a graphviz dot ast and turns it into a regular object*/


  attrListToObj = function(list) {
    var attr, ret, _i, _len;
    ret = {};
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      attr = list[_i];
      ret[attr.id] = attr.eq;
    }
    return ret;
  };

  /*
  # Light object to hold nodes and attributes of subgraphs.
  # This is really just a container and doesn't have any processing capabilities
  */


  DotSubgraph = (function() {
    function DotSubgraph(id, type, parent) {
      this.id = id;
      this.type = type != null ? type : 'subgraph';
      this.parent = parent != null ? parent : null;
      if (!this.id) {
        this.id = giveRandomKey();
        this.autogeneratedId = true;
      }
      this.nodes = {};
      this.attrs = {};
      this.graphs = {};
    }

    DotSubgraph.prototype.toString = function() {
      return this.id;
    };

    return DotSubgraph;

  })();

  /* keep the prototype accessible from the outside world*/


  DotGraph.prototype['DotSubgraph'] = DotSubgraph;

  /****************************************
  # Here is where the DotGraph methods start
  */


  function DotGraph(ast) {
    this.ast = ast;
    this.nodes = {};
    this.edges = {};
    this.graphs = {};
    this.rootGraph = new DotSubgraph();
  }

  /* walks the current ast and populates @nodes, @edges, and @graphs*/


  DotGraph.prototype.walk = function(ast) {
    var getAllNodes, walk,
      _this = this;
    if (ast == null) {
      ast = this.ast;
    }
    walk = function(tree, state, currentParentGraph) {
      var attrs, edge, elm, h, heads, id, node, oldParentGraph, t, tails, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2;
      if (state == null) {
        state = {
          node: {},
          edge: {},
          graph: {}
        };
      }
      if (tree instanceof Array) {
        for (_i = 0, _len = tree.length; _i < _len; _i++) {
          elm = tree[_i];
          walk(elm, state, currentParentGraph);
        }
      }
      switch (tree.type) {
        case 'graph':
        case 'digraph':
        case 'subgraph':
          oldParentGraph = currentParentGraph;
          currentParentGraph = new DotSubgraph(tree.id || null, tree.type, currentParentGraph);
          /*
          # when a subgraph of the same name as an already defined subgraph is mentioned,
          # it is considered an extension of the original definition--i.e., it doesn't
          # override the previous definition, so just continue on as if nothing ever happened
          */

          if (_this.graphs[currentParentGraph] != null) {
            currentParentGraph = _this.graphs[currentParentGraph];
          }
          if (oldParentGraph) {
            /* every graph should know all its child graphs*/

            oldParentGraph.graphs[currentParentGraph] = currentParentGraph;
          }
          _this.graphs[currentParentGraph] = currentParentGraph;
          if ((_ref = tree.type) === 'graph' || _ref === 'digraph') {
            _this.rootGraph = currentParentGraph;
            _this.rootGraph.strict = tree.strict;
          }
          /*
          # when walking a subgraph, we have a new state that inherits
          # anything lying around from the old state
          */

          state = doubleCopy(state);
          walk(tree.children, state, currentParentGraph);
          break;
        case 'node_stmt':
          id = tree.node_id.id;
          _this.nodes[id] = _this.nodes[id] || {
            attrs: {}
          };
          /*
          # any attributes that are specified directly with this node override
          # the attributes previously specified for a node
          */

          mergeLeftOverried(_this.nodes[id].attrs, attrListToObj(tree.attr_list));
          /*
          # the global node attributes don't overried specified attributes
          */

          mergeLeftNoOverried(_this.nodes[id].attrs, state.node);
          /*
          # let's also make sure that we keep track of which subgraph
          # has this node as a parent; we don't need to store the attr informatation
          # though, just the nodes existance
          */

          currentParentGraph.nodes[id] = true;
          break;
        case 'attr_stmt':
          /*
          # when we set a node, edge, or graph attribute using "node [attrs]"
          # syntax, it should affect everything, globally, from here on out,
          # so we really do want to update by ref
          */

          mergeLeftOverried(state[tree.target], attrListToObj(tree.attr_list));
          break;
        case 'edge_stmt':
          /*
          # first make sure all the nodes are added
          */

          _ref1 = tree.edge_list;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            node = _ref1[_j];
            if (node.type === 'node_id') {
              walk({
                type: 'node_stmt',
                node_id: node,
                attr_list: []
              }, state, currentParentGraph);
            } else if (node.type === 'subgraph') {
              walk(node, state, currentParentGraph);
            }
          }
          /*
          # now let's build up our edges
          # TODO: this doesn't actually get all the nodes we're supposed to point to...if
          # you define a subgraph twice with the same name, it needs to be combined before
          # computing it's child nodes.  e.g. "x->subgraph a {y}; subgraph a {z}"
          # should produce edges x->y and x->z.  Not sure of an easy fix atm...
          */

          heads = getAllNodes(tree.edge_list[0]);
          _ref2 = tree.edge_list.slice(1);
          for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
            node = _ref2[_k];
            tails = getAllNodes(node);
            for (_l = 0, _len3 = heads.length; _l < _len3; _l++) {
              h = heads[_l];
              for (_m = 0, _len4 = tails.length; _m < _len4; _m++) {
                t = tails[_m];
                edge = [h, t];
                attrs = mergeLeftNoOverried(attrListToObj(tree.attr_list), state.edge);
                _this.edges[edge] = _this.edges[edge] || [];
                _this.edges[edge].push({
                  edge: edge,
                  attrs: attrs
                });
              }
            }
            heads = tails;
          }
      }
      /*
      # any attributes that were set to our graph state nomatter where
      # in the AST should be applied to the current parent.  currentParentGraph
      # is reassigned every time we pass to a subgraph.
      */

      currentParentGraph.attrs = state.graph;
    };
    /*
    # walks a tree and returns a list of all nodes, disregarding
    # all other elements and attributes
    */

    getAllNodes = function(tree) {
      var n, ret, _i, _len;
      ret = [];
      if (tree instanceof Array) {
        for (_i = 0, _len = tree.length; _i < _len; _i++) {
          n = tree[_i];
          ret = ret.concat(getAllNodes(n));
        }
        return ret;
      }
      switch (tree.type) {
        case 'node_id':
          ret.push(tree.id);
          break;
        case 'node_stmt':
          ret.push(tree.node_id.id);
          break;
        case 'edge_stmt':
          ret = ret.concat(getAllNodes(tree.edge_list));
          break;
        case 'graph':
        case 'digraph':
        case 'subgraph':
          ret = ret.concat(getAllNodes(tree.children));
      }
      return ret;
    };
    walk(ast);
    this.id = this.rootGraph.id;
    this.type = this.rootGraph.type;
    this.strict = this.rootGraph.strict;
    return this;
  };

  DotGraph.prototype.generateAst = function() {
    var e, genAttrsAst, genEdgesAst, genNodeAst, genSubgraphAst, k, root, v, _i, _len, _ref, _ref1;
    genAttrsAst = function(attrs) {
      var k, ret, v;
      if (!attrs || !attrs instanceof Object) {
        return null;
      }
      ret = [];
      for (k in attrs) {
        v = attrs[k];
        ret.push({
          type: 'attr',
          id: k,
          eq: v
        });
      }
      return ret;
    };
    genEdgesAst = function(edge) {
      var attrList, ret;
      ret = {
        type: 'edge_stmt',
        edge_list: [
          {
            type: 'node_id',
            id: edge.edge[0]
          }, {
            type: 'node_id',
            id: edge.edge[1]
          }
        ]
      };
      attrList = genAttrsAst(edge.attrs);
      if (attrList) {
        ret.attr_list = attrList;
      }
      return ret;
    };
    genNodeAst = function(id, attrs, html) {
      var attrList, ret;
      ret = {
        type: 'node_stmt',
        node_id: {
          type: 'node_id',
          id: id
        }
      };
      attrList = genAttrsAst(attrs.attrs);
      if (attrList) {
        ret.attr_list = attrList;
      }
      return ret;
    };
    genSubgraphAst = function(graph) {
      var k, ret, unaddedSubgraphs, v, _i, _len, _ref, _ref1, _ref2;
      ret = {
        type: graph.type,
        id: graph.autogeneratedId ? null : graph.id,
        children: []
      };
      /*
      # we need to list all clusters first, then other subgraphs
      # this way clusters take priority when a cluster's children
      # belong to more than one rankset
      */

      unaddedSubgraphs = [];
      _ref = graph.graphs;
      for (k in _ref) {
        v = _ref[k];
        if (k.slice(0, 7) === 'cluster') {
          ret.children.push(genSubgraphAst(v));
        } else {
          unaddedSubgraphs.push(v);
        }
      }
      for (_i = 0, _len = unaddedSubgraphs.length; _i < _len; _i++) {
        v = unaddedSubgraphs[_i];
        ret.children.push(genSubgraphAst(v));
      }
      _ref1 = graph.nodes;
      for (k in _ref1) {
        v = _ref1[k];
        ret.children.push(genNodeAst(k, v));
      }
      _ref2 = graph.edges;
      for (k in _ref2) {
        v = _ref2[k];
        ret.children.push(genEdgesAst(v));
      }
      if (Object.keys(graph.attrs).length > 0) {
        ret.children.push({
          type: 'attr_stmt',
          target: 'graph',
          attr_list: genAttrsAst(graph.attrs)
        });
      }
      return ret;
    };
    root = genSubgraphAst(this.rootGraph);
    if (this.strict) {
      root.strict = this.strict;
    }
    /*
    # append all the subgraphs fist, then the nodes, then the edges, then the attributes
    */

    root.children = root.children || [];
    _ref = this.nodes;
    for (k in _ref) {
      v = _ref[k];
      root.children.push(genNodeAst(k, v));
    }
    _ref1 = this.edges;
    for (k in _ref1) {
      v = _ref1[k];
      /*
      # each element of @edges is a list of edges, so add each of them
      */

      for (_i = 0, _len = v.length; _i < _len; _i++) {
        e = v[_i];
        root.children.push(genEdgesAst(e));
      }
    }
    return root;
  };

  /* adds a subgraph whose parent is @rootGraph*/


  DotGraph.prototype.addSubgraph = function(id, parent) {
    var subgraph;
    if (parent == null) {
      parent = this.rootGraph;
    }
    subgraph = new DotSubgraph(id);
    subgraph.parent = parent;
    this.graphs[subgraph] = subgraph;
    parent.graphs[subgraph] = subgraph;
    return subgraph;
  };

  DotGraph.prototype.removeNode = function(id) {
    var graph, _, _ref;
    if (this.nodes[id]) {
      delete this.nodes[id];
    }
    _ref = this.graphs;
    for (_ in _ref) {
      graph = _ref[_];
      if (graph.nodes[id]) {
        delete graph.nodes[id];
      }
    }
  };

  DotGraph.prototype.removeEdge = function(e) {
    if (this.edges[e]) {
      delete this.edges[e];
    }
  };

  DotGraph.prototype.removeSubgraph = function(id) {
    var child, graph, _, _ref;
    if (this.graphs[id]) {
      for (child in this.graphs[id].graphs) {
        if (this.graphs[child]) {
          delete this.graphs[child];
        }
      }
      _ref = this.graphs;
      for (_ in _ref) {
        graph = _ref[_];
        if (graph.graphs[id]) {
          delete graph.graphs[id];
        }
      }
      return delete this.graphs[id];
    }
  };

  return DotGraph;

})();

/*
# Extension of the DotGraph object that will parse node/edge/graph
# attributes like pos, width, height, etc. into the appropriate javascript types.
#
# All attributes are normalized to pixels for easier drawing.
*/


XDotGraph = (function(_super) {
  var Edge, negateYs, toFloatList;

  __extends(XDotGraph, _super);

  function XDotGraph() {
    _ref = XDotGraph.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  toFloatList = function(list) {
    var v;
    if (typeof list === 'string') {
      list = list.split(/[, ]/);
    }
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        v = list[_i];
        _results.push(parseFloat(v));
      }
      return _results;
    })();
  };

  negateYs = function(list) {
    var i, l, ret, _i, _len;
    ret = [];
    for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
      l = list[i];
      if (i % 2 === 0) {
        ret.push(l);
      } else {
        ret.push(-l);
      }
    }
    return ret;
  };

  /*
  # an object with an appropriate toString function
  # so we can convert our graphs back to text form.
  */


  Edge = (function() {
    function Edge(val, NEGATE_Y_COORD, hasArrowhead) {
      var arrowTarget, controlPoints, i;
      if (NEGATE_Y_COORD == null) {
        NEGATE_Y_COORD = true;
      }
      if (hasArrowhead == null) {
        hasArrowhead = true;
      }
      this.type = 'edge';
      this.controlPoints = [];
      this.arrow = null;
      val = toFloatList(val);
      if (hasArrowhead) {
        /* arrow pos are of the form "'e',arrowTargetx,arrowTargety startx,starty  <triplets of bzCurve xy-coords>, "*/

        /* get rid of 'e'*/

        val.shift();
        /* arrowTargets*/

        arrowTarget = val.splice(0, 2);
        /* origin*/

        this.origin = NEGATE_Y_COORD ? negateYs(val.splice(0, 2)) : val.splice(0, 2);
        controlPoints = [];
        i = 0;
        while (i + 6 <= val.length) {
          controlPoints.push(NEGATE_Y_COORD ? negateYs(val.slice(i, i + 6)) : val.slice(i, i + 6));
          i += 6;
        }
        this.controlPoints = controlPoints;
        this.arrow = NEGATE_Y_COORD ? negateYs(val.slice(-2).concat(arrowTarget)) : val.slice(-2).concat(arrowTarget);
      } else {
        this.origin = NEGATE_Y_COORD ? negateYs(val.splice(0, 2)) : val.splice(0, 2);
        controlPoints = [];
        i = 0;
        while (i + 6 <= val.length) {
          controlPoints.push(NEGATE_Y_COORD ? negateYs(val.slice(i, i + 6)) : val.slice(i, i + 6));
          i += 6;
        }
        this.controlPoints = controlPoints;
        this.arrow = NEGATE_Y_COORD ? negateYs(val) : val;
      }
    }

    Edge.prototype.toString = function() {
      var i, l, points, _i, _len, _ref1;
      points = [this.origin[0], this.origin[1]];
      _ref1 = this.controlPoints;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        l = _ref1[_i];
        points = points.concat(l);
      }
      points = points.concat(this.arrow.slice(-2));
      return "e," + (((function() {
        var _j, _ref2, _results;
        _results = [];
        for (i = _j = 0, _ref2 = points.length; _j < _ref2; i = _j += 2) {
          _results.push(points[i] + ',' + points[i + 1]);
        }
        return _results;
      })()).join(' '));
    };

    return Edge;

  })();

  /* It seems like this is the value that works even though the docs say 96....*/


  XDotGraph.prototype.dpi = 72;

  /* if you're drawing in a conventional environment like canvas or svg, you expect the positve y axis to point down*/


  XDotGraph.prototype.NEGATE_Y_COORD = false;

  XDotGraph.prototype.walk = function() {
    var processAttrs,
      _this = this;
    XDotGraph.__super__.walk.call(this);
    /* pre-process all edge and node attrs*/

    processAttrs = function(graph) {
      var attr, e, edge, g, h, n, val, _i, _len, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      if (graph == null) {
        return;
      }
      _ref1 = (graph != null ? graph.nodes : void 0) || {};
      for (h in _ref1) {
        n = _ref1[h];
        _ref2 = (n != null ? n.attrs : void 0) || {};
        for (attr in _ref2) {
          val = _ref2[attr];
          n.attrs[attr] = _this.parseAttr(attr, val);
        }
      }
      _ref3 = (graph != null ? graph.edges : void 0) || {};
      for (h in _ref3) {
        e = _ref3[h];
        for (_i = 0, _len = e.length; _i < _len; _i++) {
          edge = e[_i];
          _ref4 = (edge != null ? edge.attrs : void 0) || {};
          for (attr in _ref4) {
            val = _ref4[attr];
            edge.attrs[attr] = _this.parseAttr(attr, val);
          }
        }
      }
      _ref5 = (graph != null ? graph.attrs : void 0) || {};
      for (attr in _ref5) {
        val = _ref5[attr];
        graph.attrs[attr] = _this.parseAttr(attr, val);
      }
      _ref6 = (graph != null ? graph.graphs : void 0) || {};
      for (h in _ref6) {
        g = _ref6[h];
        processAttrs(g);
      }
    };
    processAttrs(this);
  };

  /*
  # recognizes keyword attrs like pos, height, etc.
  # and will parse their arguments and return the correct type
  # accordingly.  Does nothing if attr is not recognized
  */


  XDotGraph.prototype.parseAttr = function(attr, val) {
    var tmp, _ref1;
    if (!val) {
      return null;
    }
    /* if we aren't a string, we've already been parsed, and there's no need to parse again*/

    if (!(typeof val === 'string')) {
      return val;
    }
    switch (attr) {
      case 'width':
      case 'height':
        return parseFloat(val) * this.dpi;
      case 'bb':
      case 'lp':
        val = toFloatList(val);
        if (this.NEGATE_Y_COORD) {
          val = negateYs(val);
          /* if we're a bounding box, we need to switch around our coords, 'cause our lower left and upper right are upsidedown*/

          if (val.length > 2) {
            tmp = val[1];
            val[1] = val[3];
            val[3] = tmp;
          }
        }
        return val;
      case 'pos':
        /* could be x,y-coords for a node pos, or a list for an arrow pos*/

        if (val.charAt(0) === 'e') {
          return new Edge(val, this.NEGATE_Y_COORD);
        } else {
          /*XXX heuristic: if we have more than 2 values, we assume that we're an edge that doesn't have an arrowhead*/

          if (((_ref1 = val.match(/,/g)) != null ? _ref1.length : void 0) > 1) {
            return new Edge(val, this.NEGATE_Y_COORD, false);
          } else {
            if (this.NEGATE_Y_COORD) {
              return negateYs(toFloatList(val));
            } else {
              return toFloatList(val);
            }
          }
        }
    }
    return val;
  };

  return XDotGraph;

})(DotGraph);
