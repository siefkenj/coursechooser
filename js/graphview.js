// Generated by CoffeeScript 1.6.3
var GraphManager, GraphviewCreator, Mat, SVGZoomer, computeTermFromDate, loadSVG, makeResizableAndClickable, onLoad,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

loadSVG = function(url, callback) {
  var xhr;
  xhr = new XMLHttpRequest;
  xhr.onreadystatechange = function() {
    /*
    # when running from file:// xhr.status is always 0
    #if xhr.readyState is 4 and xhr.status is 200
    */

    var graph;
    if (xhr.readyState === 4) {
      graph = document.getElementById('graphview-graph');
      graph.innerHTML = xhr.responseText;
      if (typeof callback === "function") {
        callback(graph.childNodes[0]);
      }
    }
  };
  xhr.open('GET', url, true);
  xhr.setRequestHeader('Content-type', 'image/svg+xml');
  xhr.send();
};

/*
# pass in a Date object and returns {year: .., term: ..}
# object corresponding to the school year
*/


computeTermFromDate = function(date) {
  /*
  # summer: 5-8
  # fall: 9-12
  # spring: 1-5   in this case we need to subtract 1 from the year, 'cause it counts as the previous year!
  */

  var month, term, year;
  year = date.getYear() + 1900;
  month = date.getMonth();
  if ((0 <= month && month <= 4)) {
    term = 'spring';
    year -= 1;
  } else if ((4 <= month && month <= 7)) {
    term = 'summer';
  } else {
    term = 'fall';
  }
  return {
    year: year,
    term: term
  };
};

makeResizableAndClickable = function(svg, container) {
  var manager, zoomer;
  if (container == null) {
    container = document;
  }
  zoomer = new SVGZoomer(svg);
  zoomer.zoomFit();
  container.querySelector('#graphview-zoom-in').onclick = function() {
    zoomer.zoomIn();
  };
  container.querySelector('#graphview-zoom-out').onclick = function() {
    zoomer.zoomOut();
  };
  container.querySelector('#graphview-zoom-fit').onclick = function() {
    zoomer.zoomFit();
  };
  manager = new GraphManager(svg, zoomer, container);
  return manager;
};

/*
# responsible for loading the graphview template and dynamically
# injecting the appropriate stylesheets, etc.
*/


GraphviewCreator = (function() {
  function GraphviewCreator() {
    this.loadError = false;
    this.templateText = '';
    /*
    # the make file dynamically injects NAV_TEMPLATE into graphview.coffee, but we should
    # be able to use it without compiling
    */

    if (typeof NAV_TEMPLATE !== 'undefined') {
      this.templateText = NAV_TEMPLATE;
    }
    this.loadTemplate('graphview.html');
  }

  GraphviewCreator.prototype.loadTemplate = function(url, callback) {
    var xhr,
      _this = this;
    if (callback == null) {
      callback = (function() {});
    }
    if (this.loadError) {
      return;
    }
    /*
    # if things are already loaded, don't try to reload
    */

    if (this.templateText) {
      (callback.bind(this))();
      return;
    }
    xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function() {
      /*
      # when running from file:// xhr.status is always 0
      #if xhr.readyState is 4 and xhr.status is 200
      */

      if (xhr.readyState === 4) {
        if (!xhr.responseText) {
          _this.loadError = true;
        }
        _this.templateText = xhr.responseText;
        /*
        # call our callback, but to avoid hassle, make sure
        # we call it with the appropriate _this_ context.
        */

        return (callback.bind(_this))();
      }
    };
    xhr.open('GET', url, true);
    xhr.setRequestHeader('Content-type', 'image/svg+xml');
    xhr.send();
  };

  GraphviewCreator.prototype.injectHeader = function() {
    var elm, frag, _i, _j, _len, _len1, _ref, _ref1;
    if (this.loadError) {
      return;
    }
    if (!this.templateText) {
      this.loadTemplate('graphview.html', this.injectHeader);
      return;
    }
    frag = document.createElement('div');
    frag.innerHTML = this.templateText;
    _ref = frag.querySelectorAll('link[rel=stylesheet]');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      document.body.appendChild(elm);
    }
    _ref1 = frag.querySelectorAll('style');
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      elm = _ref1[_j];
      document.body.appendChild(elm);
    }
    /*
    # clean up, just in case
    */

    frag.innerHTML = '';
  };

  GraphviewCreator.prototype.createGraphviewInstance = function(svgUrl, imgElm) {
    var frag, graphviewDiv, onSvgLoadComplete, xhr,
      _this = this;
    if (this.loadError) {
      return;
    }
    if (!this.templateText) {
      this.loadTemplate('graphview.html', this.createGraphviewInstance);
      return;
    }
    frag = document.createElement('div');
    frag.innerHTML = this.templateText;
    graphviewDiv = frag.querySelector('#graphview');
    /*
    # once the svg is loaded, link it all up and inject it
    */

    onSvgLoadComplete = function(svgText) {
      var parent;
      if (!svgText || !imgElm.parentNode) {
        return;
      }
      /*
      # if we successfully have SVG text, we'll replace the image
      */

      imgElm.parentNode.replaceChild(graphviewDiv, imgElm);
      parent = graphviewDiv.querySelector('#graphview-graph');
      parent.innerHTML = svgText;
      makeResizableAndClickable(parent.querySelector('svg'), graphviewDiv);
    };
    /*
    # start the load request
    */

    xhr = new XMLHttpRequest;
    xhr.onreadystatechange = function() {
      /*
      # when running from file:// xhr.status is always 0
      #if xhr.readyState is 4 and xhr.status is 200
      */

      if (xhr.readyState === 4) {
        onSvgLoadComplete(xhr.responseText);
      }
    };
    xhr.open('GET', svgUrl, true);
    xhr.setRequestHeader('Content-type', 'image/svg+xml');
    xhr.send();
    /*
    # graphviewDiv will be dynamically updated when the svg has loaded
    */

    return graphviewDiv;
  };

  /*
  # pass in an <img> element and replaceImage will find the src url,
  # replace the extension with .svg and attempt to make an interactive
  # graph that replaces the imgElm
  */


  GraphviewCreator.prototype.replaceImage = function(imgElm) {
    var afterTemplateLoads,
      _this = this;
    afterTemplateLoads = function() {
      var url;
      url = imgElm.getAttribute('src');
      /*
      # replace the extension
      */

      url = url.replace(/\.\w*$/, '.svg');
      /*
      # let's try and replace ourselves with our ajax loaded svg
      */

      _this.createGraphviewInstance(url, imgElm);
    };
    this.loadTemplate('graphview.html', afterTemplateLoads);
  };

  return GraphviewCreator;

})();

/*
# Mini matrix library
*/


Mat = {
  row: function(n) {
    var i, ret, _i;
    ret = new Array(n);
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      ret[i] = 0;
    }
    return ret;
  },
  zeros: function(rows, cols) {
    var i, ret, _i;
    ret = new Array(rows);
    for (i = _i = 0; 0 <= rows ? _i < rows : _i > rows; i = 0 <= rows ? ++_i : --_i) {
      ret[i] = Mat.row(cols);
    }
    return ret;
  },
  identity: function(rows, cols) {
    var i, ret, _i, _ref;
    ret = Mat.zeros(rows, cols);
    for (i = _i = 0, _ref = Math.min(rows, cols); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ret[i][i] = 1;
    }
    return ret;
  },
  copy: function(mat) {
    var cols, i, ret, rows, _i;
    rows = mat.length;
    cols = mat[0].length;
    ret = new Array(rows);
    for (i = _i = 0; 0 <= rows ? _i < rows : _i > rows; i = 0 <= rows ? ++_i : --_i) {
      ret[i] = mat[i].slice();
    }
    return ret;
  },
  transpose: function(mat) {
    var cols, i, j, ret, rows, _i, _j;
    rows = mat.length;
    cols = mat[0].length;
    ret = Mat.zeros(cols, rows);
    for (i = _i = 0; 0 <= cols ? _i < cols : _i > cols; i = 0 <= cols ? ++_i : --_i) {
      for (j = _j = 0; 0 <= rows ? _j < rows : _j > rows; j = 0 <= rows ? ++_j : --_j) {
        ret[i][j] = mat[j][i];
      }
    }
    return ret;
  },
  /*
  # in-place greather-than
  */

  gt: function(mat, num) {
    var cols, i, j, rows, _i, _j;
    rows = mat.length;
    cols = mat[0].length;
    for (i = _i = 0; 0 <= rows ? _i < rows : _i > rows; i = 0 <= rows ? ++_i : --_i) {
      for (j = _j = 0; 0 <= cols ? _j < cols : _j > cols; j = 0 <= cols ? ++_j : --_j) {
        mat[i][j] = (mat[i][j] > num) | 0;
      }
    }
    return mat;
  },
  /*
  # in-place sum
  */

  sum: function(mat1, mat2) {
    var cols, i, j, ret, rows, _i, _j;
    rows = mat1.length;
    cols = mat1[0].length;
    ret = mat1;
    for (i = _i = 0; 0 <= rows ? _i < rows : _i > rows; i = 0 <= rows ? ++_i : --_i) {
      for (j = _j = 0; 0 <= cols ? _j < cols : _j > cols; j = 0 <= cols ? ++_j : --_j) {
        ret[i][j] = mat1[i][j] + mat2[i][j];
      }
    }
    return ret;
  },
  /*
  # dot product of two vectors
  */

  dot: function(vec1, vec2) {
    var i, ret, _i, _ref;
    ret = 0;
    for (i = _i = 0, _ref = vec1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      ret += vec1[i] * vec2[i];
    }
    return ret;
  },
  /*
  # multiply two matrices
  */

  mul: function(mat1, mat2) {
    var cols, i, j, mat2t, ret, rows, _i, _j;
    mat2t = Mat.transpose(mat2);
    rows = mat1.length;
    cols = mat2[0].length;
    ret = Mat.zeros(rows, cols);
    for (i = _i = 0; 0 <= rows ? _i < rows : _i > rows; i = 0 <= rows ? ++_i : --_i) {
      for (j = _j = 0; 0 <= cols ? _j < cols : _j > cols; j = 0 <= cols ? ++_j : --_j) {
        ret[i][j] = Mat.dot(mat1[i], mat2t[j]);
      }
    }
    return ret;
  },
  /*
  # raise a matrix to a power
  */

  pow: function(mat, pow) {
    /*
    # to be efficient, we compute successive squares
    # and then multiply those together to get the end result
    */

    var a, bin, curr, i, powers, ret, _i, _j, _len, _ref;
    bin = Mat.numToBinary(pow);
    powers = new Array(bin.length);
    curr = mat;
    for (i = _i = 0, _ref = bin.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      powers[i] = curr;
      curr = Mat.mul(curr, curr);
    }
    ret = Mat.identity(mat.length, mat[0].length);
    for (i = _j = 0, _len = bin.length; _j < _len; i = ++_j) {
      a = bin[i];
      if (a) {
        ret = Mat.mul(ret, powers[i]);
      }
    }
    return ret;
  },
  /*
  # returns a matrix that is a sum of at least
  # one of ever power of mat up to power at least pow.
  # e.g. powerSum(A, 3) = I + aA + bA^2 +cA^3
  */

  powerSum: function(mat, pow) {
    var bin, curr, i, _i, _ref;
    bin = Mat.numToBinary(pow);
    curr = mat;
    for (i = _i = 0, _ref = bin.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      curr = Mat.sum(Mat.mul(curr, mat), mat);
    }
    return curr;
  },
  numToBinary: function(num) {
    var curr, i, len, ret, _i;
    if (num <= 0) {
      len = 0;
    } else {
      len = Math.floor(Math.log(num) / Math.log(2)) + 1;
    }
    ret = new Array(len);
    curr = num;
    for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
      ret[i] = curr & 1;
      curr = curr >> 1;
    }
    return ret;
  },
  prettyPrint: function(mat) {
    var padd3, row, rowToStr;
    padd3 = function(num) {
      return ("   " + num).slice(-3);
    };
    rowToStr = function(row) {
      var e;
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = row.length; _i < _len; _i++) {
          e = row[_i];
          _results.push(padd3(e));
        }
        return _results;
      })()).join('');
    };
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = mat.length; _i < _len; _i++) {
        row = mat[_i];
        _results.push(rowToStr(row));
      }
      return _results;
    })()).join('\n');
  }
};

SVGZoomer = (function() {
  SVGZoomer.prototype.ZOOM_FACTOR = 1.2;

  SVGZoomer.prototype.PAN_TOLERANCE = 5;

  function SVGZoomer(svg) {
    var d, dims, e,
      _this = this;
    this.svg = svg;
    this._onMouseMove = __bind(this._onMouseMove, this);
    this._onMouseDown = __bind(this._onMouseDown, this);
    this._onMouseUp = __bind(this._onMouseUp, this);
    this.parent = this.svg.parentNode;
    /*
    # compatibility stuff
    */

    try {
      /*
      # see if we can successfully execute the builtin getElementById by trying to locate a bogus element
      */

      this.svg.querySelector('boguselement');
    } catch (_error) {
      e = _error;
      this.svg.querySelector = function(str) {
        return _this.parent.querySelector(str);
      };
      this.svg.querySelectorAll = function(str) {
        return _this.parent.querySelectorAll(str);
      };
    }
    /*
    # get the dimensions
    */

    if (this.svg.getAttribute('viewBox')) {
      dims = this.svg.getAttribute('viewBox').split(/[^\w]+/);
      dims = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = dims.length; _i < _len; _i++) {
          d = dims[_i];
          _results.push(parseFloat(d));
        }
        return _results;
      })();
      this.width = dims[2] - dims[0];
      this.height = dims[3] - dims[1];
    } else {
      this.width = parseFloat(this.svg.getAttribute('width'));
      this.height = parseFloat(this.svg.getAttribute('height'));
      this.svg.setAttribute('viewBox', "0 0 " + this.width + " " + this.height);
    }
    this.currentZoomFactor = 1;
    this.aspect = this.width / this.height;
    /* keep track of whether our last call was zoomFit or not.*/

    this.lastZoomAction = null;
    this.zoom();
    /*
    # panning state
    */

    this.buttonPressed = false;
    this.oldMousePos = [-1, -1];
    this.panning = false;
    this.totalPan = [0, 0];
    this.svg.addEventListener('mousedown', this._onMouseDown, false);
    document.body.addEventListener('mouseup', this._onMouseUp, false);
    this.svg.addEventListener('mousemove', this._onMouseMove, false);
    return;
  }

  SVGZoomer.prototype._onMouseUp = function(event) {
    this.buttonPressed = false;
    /* reset the pan state*/

    this.totalPan[0] = 0;
    this.totalPan[1] = 1;
    this.panning = false;
  };

  SVGZoomer.prototype._onMouseDown = function(event) {
    if (event.button === 0) {
      this.buttonPressed = true;
    }
  };

  SVGZoomer.prototype._onMouseMove = function(event) {
    var dx, dy, x, y;
    x = event.clientX;
    y = event.clientY;
    if (this.oldMousePos[0] === -1) {
      this.oldMousePos[0] = x;
      this.oldMousePos[1] = y;
    }
    dx = x - this.oldMousePos[0];
    dy = y - this.oldMousePos[1];
    if (!this.buttonPressed || (dx === 0 && dy === 0)) {
      this.oldMousePos[0] = x;
      this.oldMousePos[1] = y;
      return;
    }
    this.totalPan[0] += dx;
    this.totalPan[1] += dy;
    /*
    # the first time we have moved more than @PAN_TOLERANCE, we should pan by the amount accumulated
    */

    if ((!this.panning) && Math.abs(this.totalPan[0]) + Math.abs(this.totalPan[1]) > this.PAN_TOLERANCE) {
      this.panning = true;
      dx = this.totalPan[0];
      dy = this.totalPan[1];
    }
    if (this.panning) {
      this.parent.scrollTop -= dy;
      this.parent.scrollLeft -= dx;
    }
    this.oldMousePos[0] = x;
    this.oldMousePos[1] = y;
  };

  SVGZoomer.prototype.zoomIn = function(factor) {
    if (factor == null) {
      factor = this.ZOOM_FACTOR;
    }
    this.lastZoomAction = 'in';
    this.currentZoomFactor *= factor;
    this.zoom();
  };

  SVGZoomer.prototype.zoomOut = function(factor) {
    if (factor == null) {
      factor = this.ZOOM_FACTOR;
    }
    this.lastZoomAction = 'out';
    this.currentZoomFactor /= factor;
    this.zoom();
  };

  SVGZoomer.prototype.zoomFit = function() {
    var height, width, _ref;
    this.lastZoomAction = 'fit';
    _ref = this.parent.getBoundingClientRect(), width = _ref.width, height = _ref.height;
    this.currentZoomFactor = width / this.width;
    this.zoom();
  };

  SVGZoomer.prototype.zoom = function(factor) {
    var height, width;
    if (factor == null) {
      factor = this.currentZoomFactor;
    }
    width = Math.round(this.width * factor);
    height = Math.round(this.height * factor);
    this.zoomedWidth = width;
    this.zoomedHeight = height;
    this.svg.setAttribute('width', width);
    this.svg.setAttribute('height', height);
    /*
    # webkit hack: For some reason svg attribute values for width don't work when theyre smaller than viewbox width
    */

    this.svg.setAttribute('style', "width: " + width + "; height: " + height + ";");
  };

  return SVGZoomer;

})();

GraphManager = (function() {
  var addClass, hashCourse, removeClass, sanitizeId;

  hashCourse = function(course) {
    if (typeof course === 'string') {
      return course;
    }
    return "" + course.subject + " " + course.number;
  };

  sanitizeId = function(str) {
    return ('' + str).replace(/\W+/g, '-');
  };

  addClass = function(elm, cls) {
    var oldCls;
    oldCls = elm.getAttribute('class') || '';
    if (oldCls.split(/\s+/).indexOf(cls) >= 0) {
      return;
    }
    elm.setAttribute('class', oldCls + ' ' + cls);
  };

  removeClass = function(elm, cls) {
    var c, newCls, oldCls;
    oldCls = elm.getAttribute('class') || '';
    if (!oldCls.match(cls)) {
      return;
    }
    newCls = (function() {
      var _i, _len, _ref, _results;
      _ref = oldCls.split(/\s+/);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (c !== cls) {
          _results.push(c);
        }
      }
      return _results;
    })();
    elm.setAttribute('class', newCls.join(' '));
  };

  function GraphManager(svg, zoomer, container) {
    var closeInfoArea, coop, desc, e, elm, info, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2,
      _this = this;
    this.svg = svg;
    this.zoomer = zoomer;
    this.container = container != null ? container : document;
    this._onPrereqHoverLeave = __bind(this._onPrereqHoverLeave, this);
    this._onPrereqHoverEnter = __bind(this._onPrereqHoverEnter, this);
    this._onCourseClicked = __bind(this._onCourseClicked, this);
    this._onClick = __bind(this._onClick, this);
    /*
    # compatibility stuff
    */

    try {
      /*
      # see if we can successfully execute the builtin querySelector by trying to locate a bogus element
      # It is not enought to check @svg.querySelector == null, since it is defined in Firefox 10, but throws an error
      */

      this.svg.querySelector('boguselement');
    } catch (_error) {
      e = _error;
      this.svg.querySelector = function(str) {
        return _this.parent.querySelector(str);
      };
      this.svg.querySelectorAll = function(str) {
        return _this.parent.querySelectorAll(str);
      };
    }
    this.parent = this.svg.parentNode;
    this.divCourseinfo = this.container.querySelector('#graphview-courseinfo');
    this.divGraph = this.container.querySelector('#graphview-graph');
    this.divNav = this.container.querySelector('#graphview-nav');
    this.currentlySelected = null;
    this.currentlySelectedTerms = {
      fall: true,
      spring: true,
      summer: true
    };
    /*
    # remove any styles that have been inserted, we will use stylesheets instead
    */

    _ref = this.svg.querySelectorAll('*');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      elm.removeAttribute('style');
    }
    this.data = JSON.parse(decodeURIComponent(this.svg.querySelector('coursemapper').textContent));
    this.processData();
    /*
    # ensure nodes are clickable and set their title appropriately
    */

    _ref1 = this.svg.querySelectorAll('g.node');
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      elm = _ref1[_j];
      elm.addEventListener('click', this._onCourseClicked, true);
      info = this.courses[elm.courseHash];
      if (info) {
        try {
          desc = "" + info.subject + " " + info.number + ": " + info.data.title;
          elm.setAttribute('title', desc);
        } catch (_error) {
          e = _error;
          '';
        }
      }
    }
    _ref2 = this.data.coops || [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      coop = _ref2[_k];
      try {
        elm = this.svg.getElementById(coop.id);
        elm._coopLink = coop.url;
        elm.setAttribute('title', coop.label);
        if (elm._coopLink) {
          elm.onclick = function(event) {
            window.open(event.currentTarget._coopLink);
          };
        }
      } catch (_error) {
        e = _error;
        '';
      }
    }
    /*
    # closable infoarea
    */

    closeInfoArea = function() {
      var _ref3;
      _this.setCourseinfoVisibility(false);
      /*
      # if you zoom-fit while the infoarea was open and you
      # close it, you expect the graph to fit to the newly-enlarged area
      */

      if (((_ref3 = _this.zoomer) != null ? _ref3.lastZoomAction : void 0) === 'fit') {
        _this.zoomer.zoomFit();
      }
    };
    this.divCourseinfo.querySelector('.graphview-close-button').addEventListener('click', closeInfoArea, true);
    /*
    # set up the term selection menu
    */

    this.divNav.querySelector('#graphview-term-menu-fall').addEventListener('click', this._createTermToggler('fall'), true);
    this.divNav.querySelector('#graphview-term-menu-spring').addEventListener('click', this._createTermToggler('spring'), true);
    this.divNav.querySelector('#graphview-term-menu-summer').addEventListener('click', this._createTermToggler('summer'), true);
  }

  /*
  # Get a list of all the nodes and their corresponding
  # dom elements and tag each dom element with an expando
  # property linking back to its name
  */


  GraphManager.prototype.processData = function() {
    var cluster, course, edge, elm, hash, i, j, node, numNodes, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4;
    this.courses = {};
    this.coursesList = [];
    _ref = this.data.nodes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      node = _ref[i];
      course = node.course;
      hash = hashCourse(course);
      this.courses[hash] = course;
      this.coursesList.push(hash);
      course.listPos = i;
      course.year = node.year;
      /*
      # mark each clickable node with a reference to its unmangled hash so we
      # can get back to it.
      */

      elm = this.svg.querySelector("#" + (sanitizeId(hash)));
      if (elm) {
        course.elm = elm;
        elm.courseHash = hash;
      }
    }
    /*
    # make sure any electives that aren't explicitly
    # specified have a reference to their info for use on click
    */

    _ref1 = this.data.clusters;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      cluster = _ref1[_j];
      if (!(((_ref2 = cluster.courses) != null ? _ref2.length : void 0) === 0)) {
        continue;
      }
      course = cluster.cluster;
      course.isElectivesNode = true;
      hash = hashCourse(course);
      this.courses[hash] = course;
      elm = this.svg.querySelector("#" + (sanitizeId(hash)));
      if (elm) {
        course.elm = elm;
        elm.courseHash = hash;
      }
    }
    /*
    # compute adjacency matrices
    */

    numNodes = this.coursesList.length;
    this.adjacencyMat = Mat.zeros(numNodes, numNodes);
    _ref3 = this.data.edges;
    for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
      edge = _ref3[_k];
      if ((_ref4 = edge.properties.style) != null ? _ref4.match(/invis/) : void 0) {
        continue;
      }
      i = this.courses[edge.edge[0]].listPos;
      j = this.courses[edge.edge[1]].listPos;
      this.adjacencyMat[i][j] = 1;
      if (edge.properties.coreq) {
        this.adjacencyMat[i][j] = 2;
      }
    }
    /*
    # compute coreq adjacencies
    */

    this.adjacencyMatCoreq = Mat.gt(Mat.copy(this.adjacencyMat), 1);
    this.adjacencyMatCoreq = Mat.sum(this.adjacencyMatCoreq, Mat.transpose(this.adjacencyMatCoreq));
    this.adjacencyMat = Mat.sum(this.adjacencyMat, this.adjacencyMatCoreq);
    this.span = Mat.gt(Mat.powerSum(this.adjacencyMat, this.adjacencyMat.length), 0);
    this.correqSpan = Mat.gt(Mat.powerSum(this.adjacencyMatCoreq, this.adjacencyMatCoreq.length), 0);
  };

  /*
  # returns a list of all the prereqs/coreqs for a course
  */


  GraphManager.prototype.coursePrereqs = function(course, excludeCorreqs) {
    var adjT, e, hash, i, index, ret, spanT, _i, _len, _ref;
    if (excludeCorreqs == null) {
      excludeCorreqs = false;
    }
    hash = hashCourse(course);
    /*
    # if we're not a standard course (e.g. an electives node), we wont have a listPos.
    # Bail in this case.
    */

    if (this.courses[hash].listPos == null) {
      return [];
    }
    spanT = Mat.transpose(this.span);
    /* this doesn't need to be transposed because the coreq matrix is symmetric*/

    adjT = this.adjacencyMatCoreq;
    index = this.courses[hash].listPos;
    ret = [];
    /*
    # we can get into funny situations where we appear in our own span.  We should never appear
    # in our own prereq list.
    */

    _ref = spanT[index];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      e = _ref[i];
      if (!(e && !(hash === this.coursesList[i]))) {
        continue;
      }
      /*
      # if we're in the span 'cause we're a coreq, move along
      */

      if (excludeCorreqs && adjT[index][i]) {
        continue;
      }
      ret.push(this.coursesList[i]);
    }
    return ret;
  };

  /*
  # returns a list of all the prereqs/coreqs for a course
  */


  GraphManager.prototype.courseCoreqs = function(course) {
    var adjT, e, hash, i, index, ret, _i, _len, _ref;
    hash = hashCourse(course);
    /*
    # if we're not a standard course (e.g. an electives node), we wont have a listPos.
    # Bail in this case.
    */

    if (this.courses[hash].listPos == null) {
      return [];
    }
    /* this doesn't need to be transposed because the coreq matrix is symmetric*/

    adjT = this.adjacencyMatCoreq;
    index = this.courses[hash].listPos;
    ret = [];
    /*
    # we can get into funny situations where we appear in our own span.  We should never appear
    # in our own prereq list.
    */

    _ref = adjT[index];
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      e = _ref[i];
      if (e && !(hash === this.coursesList[i])) {
        ret.push(this.coursesList[i]);
      }
    }
    return ret;
  };

  /*
  # returns a callback to be executed whenever
  # the visibility checkbox for that term is checked
  # term is in ['fall','spring','summer','any']
  */


  GraphManager.prototype._createTermToggler = function(term) {
    var callback,
      _this = this;
    callback = function() {
      var t, _i, _len, _ref;
      switch (term) {
        case 'fall':
          _this.currentlySelectedTerms['fall'] = !_this.currentlySelectedTerms['fall'];
          break;
        case 'spring':
          _this.currentlySelectedTerms['spring'] = !_this.currentlySelectedTerms['spring'];
          break;
        case 'summer':
          _this.currentlySelectedTerms['summer'] = !_this.currentlySelectedTerms['summer'];
      }
      /*
      # set the proper icons on the menu
      */

      _ref = ['fall', 'spring', 'summer'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        t = _ref[_i];
        if (_this.currentlySelectedTerms[t]) {
          _this.divNav.querySelector("#graphview-term-menu-" + t + " i").setAttribute('class', 'icon-check');
        } else {
          _this.divNav.querySelector("#graphview-term-menu-" + t + " i").setAttribute('class', 'icon-check-empty');
        }
      }
      _this.filterClassesByTerm(_this.currentlySelectedTerms);
    };
    return callback;
  };

  GraphManager.prototype._onClick = function(event) {
    var _ref;
    if (((_ref = event.target.getAttribute('class')) != null ? _ref.match(/course/) : void 0) || true) {
      event.currentTarget = event.target;
      this._onCourseClicked(event);
    }
  };

  GraphManager.prototype._onCourseClicked = function(event) {
    var elm;
    elm = event.currentTarget;
    if (this.currentlySelected === elm.courseHash) {
      this.deselectAll();
    } else {
      this.selectCourse(elm.courseHash);
    }
  };

  /*
  # select a course and highlight all its prereqs
  */


  GraphManager.prototype.selectCourse = function(course) {
    var c, elm, hash, id, prereq, prereqs, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    hash = hashCourse(course);
    prereqs = this.coursePrereqs(hash);
    /*
    # highlight all the course nodes
    */

    _ref = this.courses;
    for (_ in _ref) {
      c = _ref[_];
      removeClass(c.elm, 'highlight');
      removeClass(c.elm, 'highlight2');
    }
    for (_i = 0, _len = prereqs.length; _i < _len; _i++) {
      prereq = prereqs[_i];
      addClass(this.courses[prereq].elm, 'highlight');
    }
    addClass(this.courses[hash].elm, 'highlight');
    /*
    # highlight all the prereq arrows
    */

    _ref1 = this.svg.querySelectorAll('g.edge');
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      elm = _ref1[_j];
      removeClass(elm, 'highlight');
    }
    _ref2 = prereqs.concat([hash]);
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      prereq = _ref2[_k];
      id = sanitizeId(prereq);
      _ref3 = this.svg.querySelectorAll("[target=" + id + "]");
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        elm = _ref3[_l];
        addClass(elm, 'highlight');
      }
    }
    this.createCourseSummary(course);
    this.currentlySelected = course;
    this.setCourseinfoVisibility(true);
  };

  GraphManager.prototype.deselectAll = function() {
    var c, elm, _, _i, _len, _ref, _ref1;
    _ref = this.courses;
    for (_ in _ref) {
      c = _ref[_];
      removeClass(c.elm, 'highlight');
      removeClass(c.elm, 'highlight2');
    }
    _ref1 = this.svg.querySelectorAll('g.edge');
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      elm = _ref1[_i];
      removeClass(elm, 'highlight');
    }
    this.currentlySelected = null;
    this.setCourseinfoVisibility(false);
  };

  GraphManager.prototype.courseRequirementsSummary = function(course) {
    var c, coreq, coreqs, hash, prereq, prereqs, years, _i, _j, _len, _len1;
    hash = hashCourse(course);
    prereqs = this.coursePrereqs(hash, true);
    years = {
      1: [],
      2: [],
      3: [],
      4: []
    };
    for (_i = 0, _len = prereqs.length; _i < _len; _i++) {
      prereq = prereqs[_i];
      c = this.courses[prereq];
      years[c.year] = years[c.year] || [];
      years[c.year].push(c);
    }
    coreqs = this.courseCoreqs(hash);
    years['coreq'] = [];
    for (_j = 0, _len1 = coreqs.length; _j < _len1; _j++) {
      coreq = coreqs[_j];
      c = this.courses[coreq];
      years['coreq'].push(c);
    }
    return years;
  };

  GraphManager.prototype.createCourseSummary = function(course) {
    var academicTerm, c, calendarLink, elm, emailRegexp, formatted, hash, infoArea, infoLink, li, link, list, numPrereqs, parent, prereqs, requirement, term, urlRegex, year, years, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref17, _ref18, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
      _this = this;
    hash = hashCourse(course);
    course = this.courses[course];
    infoArea = this.container.querySelector('#graphview-courseinfo');
    /*
    # we have a special display if we're an electives node
    */

    if (course.isElectivesNode) {
      addClass(infoArea.querySelector('#graphview-courseinfo-text'), 'invisible');
      infoArea = infoArea.querySelector('#graphview-electivesinfo-text');
      removeClass(infoArea, 'invisible');
      if ((_ref = infoArea.querySelector('.name')) != null) {
        _ref.textContent = course.title;
      }
      link = ((_ref1 = course.data) != null ? _ref1.url : void 0) || '#';
      calendarLink = infoArea.querySelector('#graphview-electivesinfo-link');
      if (calendarLink) {
        calendarLink.setAttribute('href', link);
      }
      if ((_ref2 = course.data) != null ? _ref2.url : void 0) {
        removeClass(infoArea.querySelector('.moreinfo'), 'invisible');
        infoLink = infoArea.querySelector('.moreinfo a');
        infoLink.setAttribute('href', link);
        infoLink.textContent = link;
      } else {
        addClass(infoArea.querySelector('.moreinfo'), 'invisible');
      }
      requirement = "" + ((_ref3 = course.requirements) != null ? _ref3.units : void 0) + " " + ((_ref4 = course.requirements) != null ? _ref4.unitLabel : void 0);
      if ((_ref5 = infoArea.querySelector('.title')) != null) {
        _ref5.textContent = requirement;
      }
      if ((_ref6 = course.data) != null ? _ref6.description : void 0) {
        /*
        # let's do some pretty formatting of the description so it looks
        # more like how it was typed
        */

        emailRegexp = /([\w\-\.]+@[\w\-\.]+)/gi;
        urlRegex = /((http:|https:)\/\/[\w\-\.~%?\/\#]+)/gi;
        formatted = course.data.description.replace(/\n(\s|\n)*\n/g, '<br/><br/>');
        formatted = formatted.replace(urlRegex, "<a href='$1'>$1</a>");
        formatted = formatted.replace(emailRegexp, "<a href='mailto::$1'>$1</a>");
        if ((_ref7 = infoArea.querySelector('.description')) != null) {
          _ref7.innerHTML = formatted;
        }
      } else {
        if ((_ref8 = infoArea.querySelector('.description')) != null) {
          _ref8.textContent = "Take " + requirement + ".";
        }
      }
      return;
    }
    addClass(infoArea.querySelector('#graphview-electivesinfo-text'), 'invisible');
    infoArea = infoArea.querySelector('#graphview-courseinfo-text');
    removeClass(infoArea, 'invisible');
    if ((_ref9 = infoArea.querySelector('.name')) != null) {
      _ref9.textContent = hash;
    }
    if ((_ref10 = infoArea.querySelector('.title')) != null) {
      _ref10.textContent = (_ref11 = course.data) != null ? _ref11.title : void 0;
    }
    /*
    # prepare the appropriate calendar link
    */

    academicTerm = computeTermFromDate(new Date);
    link = "http://web.uvic.ca/calendar" + academicTerm.year + "/CDs/" + course.subject + "/" + course.number + ".html";
    calendarLink = infoArea.querySelector('#graphview-calendar-link');
    if (calendarLink) {
      calendarLink.setAttribute('href', link);
    }
    _ref12 = ['fall', 'spring', 'summer'];
    for (_i = 0, _len = _ref12.length; _i < _len; _i++) {
      term = _ref12[_i];
      elm = infoArea.querySelector("." + term);
      if ((_ref13 = course.data) != null ? _ref13.terms_offered[term] : void 0) {
        removeClass(elm, "hidden");
      } else {
        addClass(elm, "hidden");
      }
    }
    if ((_ref14 = infoArea.querySelector('.description')) != null) {
      _ref14.textContent = (_ref15 = course.data) != null ? _ref15.description : void 0;
    }
    /*
    # construct the prereq list
    */

    years = this.courseRequirementsSummary(course);
    numPrereqs = years[1].length + years[2].length + years[3].length + years[4].length;
    if (numPrereqs > 0) {
      removeClass(infoArea.querySelector('.prereq'), "invisible");
      _ref16 = [1, 2, 3, 4];
      for (_j = 0, _len1 = _ref16.length; _j < _len1; _j++) {
        year = _ref16[_j];
        parent = infoArea.querySelector(".year" + year);
        elm = parent.querySelector('ul');
        list = [];
        prereqs = years[year];
        for (_k = 0, _len2 = prereqs.length; _k < _len2; _k++) {
          c = prereqs[_k];
          list.push("<li title='" + c.subject + " " + c.number + ": " + c.data.title + "' course='" + (hashCourse(c)) + "'>" + (hashCourse(c)) + "</li>");
        }
        list.sort();
        if (elm != null) {
          elm.innerHTML = list.join('');
        }
        if (list.length === 0) {
          addClass(parent, "invisible");
        } else {
          removeClass(parent, "invisible");
        }
        /*
        # make the pre-reqs highlight on hover and make the clickable
        */

        _ref17 = (elm != null ? elm.querySelectorAll('li') : void 0) || [];
        for (_l = 0, _len3 = _ref17.length; _l < _len3; _l++) {
          li = _ref17[_l];
          li.onmouseover = this._onPrereqHoverEnter;
          li.onmouseout = this._onPrereqHoverLeave;
          li.onclick = function(event) {
            elm = event.currentTarget;
            course = elm.getAttribute('course');
            _this.selectCourse(course);
          };
        }
      }
    } else {
      addClass(infoArea.querySelector('.prereq'), "invisible");
    }
    /*
    # construct the prereq list
    */

    parent = infoArea.querySelector(".coreq");
    elm = parent.querySelector('ul');
    list = [];
    prereqs = years['coreq'];
    for (_m = 0, _len4 = prereqs.length; _m < _len4; _m++) {
      c = prereqs[_m];
      list.push("<li title='" + c.subject + " " + c.number + ": " + c.data.title + "'>" + (hashCourse(c)) + "</li>");
    }
    list.sort();
    if (elm != null) {
      elm.innerHTML = list.join('');
    }
    /*
    # make the co-reqs highlight on hover and make the clickable
    */

    _ref18 = (elm != null ? elm.querySelectorAll('li') : void 0) || [];
    for (_n = 0, _len5 = _ref18.length; _n < _len5; _n++) {
      li = _ref18[_n];
      li.onmouseover = this._onPrereqHoverEnter;
      li.onmouseout = this._onPrereqHoverLeave;
      li.onclick = function(event) {
        elm = event.currentTarget;
        course = elm.getAttribute('course');
        _this.selectCourse(course);
      };
    }
    if (list.length === 0) {
      addClass(parent, "invisible");
    } else {
      removeClass(parent, "invisible");
    }
  };

  GraphManager.prototype._onPrereqHoverEnter = function(event) {
    var course, courseHash, elm;
    elm = event.currentTarget;
    courseHash = elm.getAttribute('course');
    course = this.courses[courseHash];
    if (course) {
      addClass(course.elm, 'highlight2');
    }
  };

  GraphManager.prototype._onPrereqHoverLeave = function(event) {
    var course, courseHash, elm;
    elm = event.currentTarget;
    courseHash = elm.getAttribute('course');
    course = this.courses[courseHash];
    if (course) {
      removeClass(course.elm, 'highlight2');
    }
  };

  /*
  # sets whether the courseinfo area is visible or not.
  # This function handles resizing of the graph area, etc.
  */


  GraphManager.prototype.setCourseinfoVisibility = function(visible) {
    if (visible == null) {
      visible = true;
    }
    if (visible) {
      removeClass(this.divCourseinfo, 'invisible');
      addClass(this.divGraph, 'sidepanel-visible');
    } else {
      addClass(this.divCourseinfo, 'invisible');
      removeClass(this.divGraph, 'sidepanel-visible');
    }
  };

  /*
  # pass in an object with the terms you want to be visible.
  # Courses only offered in other terms will be transparent
  */


  GraphManager.prototype.filterClassesByTerm = function(terms) {
    var course, elm, isOfferedInTerms, _i, _len, _ref;
    if (terms == null) {
      terms = {
        summer: true,
        fall: true,
        spring: true
      };
    }
    isOfferedInTerms = function(course) {
      var term, v, _ref;
      for (term in terms) {
        v = terms[term];
        if (v) {
          if ((_ref = course.data.terms_offered) != null ? _ref[term] : void 0) {
            return true;
          }
        }
      }
      return false;
    };
    _ref = this.svg.querySelectorAll('.node');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      course = this.courses[elm.courseHash];
      if (isOfferedInTerms(course) || course.isElectivesNode) {
        removeClass(elm, 'transparent');
      } else {
        addClass(elm, 'transparent');
      }
    }
  };

  return GraphManager;

})();

/*
# set it up so that images with the graphview attribute
# are dynamically replaced with interactive maps
*/


onLoad = function() {
  /*
  # only attempt to make the picture fancy if the browser has support for SVG images in the first place
  */

  var creator, elm, _i, _len, _ref, _results;
  if (window.SVGElement != null) {
    creator = new GraphviewCreator;
    creator.injectHeader();
    _ref = document.querySelectorAll('[graphview=true]');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      _results.push(creator.replaceImage(elm));
    }
    return _results;
  }
};

window.addEventListener('load', onLoad, true);
